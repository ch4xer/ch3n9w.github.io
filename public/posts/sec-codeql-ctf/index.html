<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>CodeQL CTF ä¹‹ Go and don&#39;t return | ch3n9w ã® è¶…å…ƒåŸŸ</title>
<meta name="keywords" content="">
<meta name="description" content="Go and don&rsquo;t return
è¿™é“é¢˜ç›®ä»MinIOçš„ä¸€ä¸ªå·²å…¬å¼€çš„æœªæˆæƒè®¿é—®æ¼æ´å¼€å§‹, é€šè¿‡ç¼–å†™å¹¶æ…¢æ…¢å®Œå–„CodeQLè¯­å¥æ¥æ£€æµ‹è¯¥æ¼æ´åœ¨ä»£ç ä¸­çš„ä½ç½®. éšç€é¢˜ç›®çš„è¿›è¡Œ, é¢˜ç›®å°†ç›®æ ‡å°†æ‰©å±•åˆ°æ­¤ç±»æ¼æ´çš„å„ç§å˜ç§, éš¾åº¦é€æ¸åŠ æ·±, éå¸¸é€‚åˆç”¨æ¥å…¥é—¨å’Œå­¦ä¹ . æœ¬æ–‡æ˜¯ç”¨æ¥è®°å½•æˆ‘åœ¨é˜…è¯»å®˜æ–¹é¢˜è§£æ—¶çš„æ€è€ƒè¿‡ç¨‹, å› ä¸ºæˆ‘åœ¨Part2å°±å¡ä½å•¦hhhhhhh.
ğŸ”—åŸé¢˜ç›®é“¾æ¥
ğŸ”—å®˜æ–¹å‚è€ƒé¢˜è§£é“¾æ¥
åœ¨å¼€å§‹ä¹‹å‰, å¯ä»¥æŸ¥çœ‹ä¸€ä¸‹è¯¥æ¼æ´çš„ç»†èŠ‚ å’Œ æè¿°, å‘ç°è¯¥æ¼æ´çš„åŸç†å…¶å®ååˆ†ç®€å•, å°±æ˜¯åœ¨ if s3Err != ErrNone åˆ¤æ–­ä¹‹åæ²¡æœ‰å°†ä¸åˆæ³•çš„æ§åˆ¶æµè¿”å›, è€Œæ˜¯ä»»ç”±å®ƒç»§ç»­è¿›å…¥æ¥ä¸‹å»çš„claims, s3Err := checkClaimsFromToken(r, cred), å¯¼è‡´æ ¡éªŒå¤±è´¥.
å…·ä½“çš„æ¼æ´åˆ©ç”¨å¯ä»¥çœ‹è¿™é‡Œ
Part 1: Letâ€™s catch the bug!
1.1: Finding references to ErrNone

Write the query that finds all identifiers named ErrNone. You will find in the documentation the relevant object types to query. Your query should return 231 results.


import go

from Ident i
where i.getName() = &#34;ErrNone&#34; //Identå°±æ˜¯æ ‡è¯†ç¬¦
select i
è¿è¡Œåå°±å¯ä»¥æ£€ç´¢å‡ºErrNoneå‡ºç°è¿‡çš„æ‰€æœ‰ä½ç½®.">
<meta name="author" content="ch3n9w">
<link rel="canonical" href="https://dragonbox.top/posts/sec-codeql-ctf/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://dragonbox.top/flash.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://dragonbox.top/flash.ico">
<link rel="icon" type="image/png" sizes="32x32" href="https://dragonbox.top/flash.ico">
<link rel="apple-touch-icon" href="https://dragonbox.top/flash.ico">
<link rel="mask-icon" href="https://dragonbox.top/flash.ico">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://dragonbox.top/posts/sec-codeql-ctf/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="CodeQL CTF ä¹‹ Go and don&#39;t return" />
<meta property="og:description" content="Go and don&rsquo;t return
è¿™é“é¢˜ç›®ä»MinIOçš„ä¸€ä¸ªå·²å…¬å¼€çš„æœªæˆæƒè®¿é—®æ¼æ´å¼€å§‹, é€šè¿‡ç¼–å†™å¹¶æ…¢æ…¢å®Œå–„CodeQLè¯­å¥æ¥æ£€æµ‹è¯¥æ¼æ´åœ¨ä»£ç ä¸­çš„ä½ç½®. éšç€é¢˜ç›®çš„è¿›è¡Œ, é¢˜ç›®å°†ç›®æ ‡å°†æ‰©å±•åˆ°æ­¤ç±»æ¼æ´çš„å„ç§å˜ç§, éš¾åº¦é€æ¸åŠ æ·±, éå¸¸é€‚åˆç”¨æ¥å…¥é—¨å’Œå­¦ä¹ . æœ¬æ–‡æ˜¯ç”¨æ¥è®°å½•æˆ‘åœ¨é˜…è¯»å®˜æ–¹é¢˜è§£æ—¶çš„æ€è€ƒè¿‡ç¨‹, å› ä¸ºæˆ‘åœ¨Part2å°±å¡ä½å•¦hhhhhhh.
ğŸ”—åŸé¢˜ç›®é“¾æ¥
ğŸ”—å®˜æ–¹å‚è€ƒé¢˜è§£é“¾æ¥
åœ¨å¼€å§‹ä¹‹å‰, å¯ä»¥æŸ¥çœ‹ä¸€ä¸‹è¯¥æ¼æ´çš„ç»†èŠ‚ å’Œ æè¿°, å‘ç°è¯¥æ¼æ´çš„åŸç†å…¶å®ååˆ†ç®€å•, å°±æ˜¯åœ¨ if s3Err != ErrNone åˆ¤æ–­ä¹‹åæ²¡æœ‰å°†ä¸åˆæ³•çš„æ§åˆ¶æµè¿”å›, è€Œæ˜¯ä»»ç”±å®ƒç»§ç»­è¿›å…¥æ¥ä¸‹å»çš„claims, s3Err := checkClaimsFromToken(r, cred), å¯¼è‡´æ ¡éªŒå¤±è´¥.
å…·ä½“çš„æ¼æ´åˆ©ç”¨å¯ä»¥çœ‹è¿™é‡Œ
Part 1: Letâ€™s catch the bug!
1.1: Finding references to ErrNone

Write the query that finds all identifiers named ErrNone. You will find in the documentation the relevant object types to query. Your query should return 231 results.


import go

from Ident i
where i.getName() = &#34;ErrNone&#34; //Identå°±æ˜¯æ ‡è¯†ç¬¦
select i
è¿è¡Œåå°±å¯ä»¥æ£€ç´¢å‡ºErrNoneå‡ºç°è¿‡çš„æ‰€æœ‰ä½ç½®." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dragonbox.top/posts/sec-codeql-ctf/" />
<meta property="og:image" content="https://dragonbox.top/cover.png" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-12-06T09:03:06+08:00" />
<meta property="article:modified_time" content="2024-12-06T09:03:06+08:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://dragonbox.top/cover.png" />
<meta name="twitter:title" content="CodeQL CTF ä¹‹ Go and don&#39;t return"/>
<meta name="twitter:description" content="Go and don&rsquo;t return
è¿™é“é¢˜ç›®ä»MinIOçš„ä¸€ä¸ªå·²å…¬å¼€çš„æœªæˆæƒè®¿é—®æ¼æ´å¼€å§‹, é€šè¿‡ç¼–å†™å¹¶æ…¢æ…¢å®Œå–„CodeQLè¯­å¥æ¥æ£€æµ‹è¯¥æ¼æ´åœ¨ä»£ç ä¸­çš„ä½ç½®. éšç€é¢˜ç›®çš„è¿›è¡Œ, é¢˜ç›®å°†ç›®æ ‡å°†æ‰©å±•åˆ°æ­¤ç±»æ¼æ´çš„å„ç§å˜ç§, éš¾åº¦é€æ¸åŠ æ·±, éå¸¸é€‚åˆç”¨æ¥å…¥é—¨å’Œå­¦ä¹ . æœ¬æ–‡æ˜¯ç”¨æ¥è®°å½•æˆ‘åœ¨é˜…è¯»å®˜æ–¹é¢˜è§£æ—¶çš„æ€è€ƒè¿‡ç¨‹, å› ä¸ºæˆ‘åœ¨Part2å°±å¡ä½å•¦hhhhhhh.
ğŸ”—åŸé¢˜ç›®é“¾æ¥
ğŸ”—å®˜æ–¹å‚è€ƒé¢˜è§£é“¾æ¥
åœ¨å¼€å§‹ä¹‹å‰, å¯ä»¥æŸ¥çœ‹ä¸€ä¸‹è¯¥æ¼æ´çš„ç»†èŠ‚ å’Œ æè¿°, å‘ç°è¯¥æ¼æ´çš„åŸç†å…¶å®ååˆ†ç®€å•, å°±æ˜¯åœ¨ if s3Err != ErrNone åˆ¤æ–­ä¹‹åæ²¡æœ‰å°†ä¸åˆæ³•çš„æ§åˆ¶æµè¿”å›, è€Œæ˜¯ä»»ç”±å®ƒç»§ç»­è¿›å…¥æ¥ä¸‹å»çš„claims, s3Err := checkClaimsFromToken(r, cred), å¯¼è‡´æ ¡éªŒå¤±è´¥.
å…·ä½“çš„æ¼æ´åˆ©ç”¨å¯ä»¥çœ‹è¿™é‡Œ
Part 1: Letâ€™s catch the bug!
1.1: Finding references to ErrNone

Write the query that finds all identifiers named ErrNone. You will find in the documentation the relevant object types to query. Your query should return 231 results.


import go

from Ident i
where i.getName() = &#34;ErrNone&#34; //Identå°±æ˜¯æ ‡è¯†ç¬¦
select i
è¿è¡Œåå°±å¯ä»¥æ£€ç´¢å‡ºErrNoneå‡ºç°è¿‡çš„æ‰€æœ‰ä½ç½®."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://dragonbox.top/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "CodeQL CTF ä¹‹ Go and don't return",
      "item": "https://dragonbox.top/posts/sec-codeql-ctf/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CodeQL CTF ä¹‹ Go and don't return",
  "name": "CodeQL CTF ä¹‹ Go and don\u0027t return",
  "description": "Go and don\u0026rsquo;t return è¿™é“é¢˜ç›®ä»MinIOçš„ä¸€ä¸ªå·²å…¬å¼€çš„æœªæˆæƒè®¿é—®æ¼æ´å¼€å§‹, é€šè¿‡ç¼–å†™å¹¶æ…¢æ…¢å®Œå–„CodeQLè¯­å¥æ¥æ£€æµ‹è¯¥æ¼æ´åœ¨ä»£ç ä¸­çš„ä½ç½®. éšç€é¢˜ç›®çš„è¿›è¡Œ, é¢˜ç›®å°†ç›®æ ‡å°†æ‰©å±•åˆ°æ­¤ç±»æ¼æ´çš„å„ç§å˜ç§, éš¾åº¦é€æ¸åŠ æ·±, éå¸¸é€‚åˆç”¨æ¥å…¥é—¨å’Œå­¦ä¹ . æœ¬æ–‡æ˜¯ç”¨æ¥è®°å½•æˆ‘åœ¨é˜…è¯»å®˜æ–¹é¢˜è§£æ—¶çš„æ€è€ƒè¿‡ç¨‹, å› ä¸ºæˆ‘åœ¨Part2å°±å¡ä½å•¦hhhhhhh.\nğŸ”—åŸé¢˜ç›®é“¾æ¥\nğŸ”—å®˜æ–¹å‚è€ƒé¢˜è§£é“¾æ¥\nåœ¨å¼€å§‹ä¹‹å‰, å¯ä»¥æŸ¥çœ‹ä¸€ä¸‹è¯¥æ¼æ´çš„ç»†èŠ‚ å’Œ æè¿°, å‘ç°è¯¥æ¼æ´çš„åŸç†å…¶å®ååˆ†ç®€å•, å°±æ˜¯åœ¨ if s3Err != ErrNone åˆ¤æ–­ä¹‹åæ²¡æœ‰å°†ä¸åˆæ³•çš„æ§åˆ¶æµè¿”å›, è€Œæ˜¯ä»»ç”±å®ƒç»§ç»­è¿›å…¥æ¥ä¸‹å»çš„claims, s3Err := checkClaimsFromToken(r, cred), å¯¼è‡´æ ¡éªŒå¤±è´¥.\nå…·ä½“çš„æ¼æ´åˆ©ç”¨å¯ä»¥çœ‹è¿™é‡Œ\nPart 1: Letâ€™s catch the bug! 1.1: Finding references to ErrNone Write the query that finds all identifiers named ErrNone. You will find in the documentation the relevant object types to query. Your query should return 231 results.\nimport go from Ident i where i.getName() = \u0026#34;ErrNone\u0026#34; //Identå°±æ˜¯æ ‡è¯†ç¬¦ select i è¿è¡Œåå°±å¯ä»¥æ£€ç´¢å‡ºErrNoneå‡ºç°è¿‡çš„æ‰€æœ‰ä½ç½®.\n",
  "keywords": [
    
  ],
  "articleBody": "Go and donâ€™t return è¿™é“é¢˜ç›®ä»MinIOçš„ä¸€ä¸ªå·²å…¬å¼€çš„æœªæˆæƒè®¿é—®æ¼æ´å¼€å§‹, é€šè¿‡ç¼–å†™å¹¶æ…¢æ…¢å®Œå–„CodeQLè¯­å¥æ¥æ£€æµ‹è¯¥æ¼æ´åœ¨ä»£ç ä¸­çš„ä½ç½®. éšç€é¢˜ç›®çš„è¿›è¡Œ, é¢˜ç›®å°†ç›®æ ‡å°†æ‰©å±•åˆ°æ­¤ç±»æ¼æ´çš„å„ç§å˜ç§, éš¾åº¦é€æ¸åŠ æ·±, éå¸¸é€‚åˆç”¨æ¥å…¥é—¨å’Œå­¦ä¹ . æœ¬æ–‡æ˜¯ç”¨æ¥è®°å½•æˆ‘åœ¨é˜…è¯»å®˜æ–¹é¢˜è§£æ—¶çš„æ€è€ƒè¿‡ç¨‹, å› ä¸ºæˆ‘åœ¨Part2å°±å¡ä½å•¦hhhhhhh.\nğŸ”—åŸé¢˜ç›®é“¾æ¥\nğŸ”—å®˜æ–¹å‚è€ƒé¢˜è§£é“¾æ¥\nåœ¨å¼€å§‹ä¹‹å‰, å¯ä»¥æŸ¥çœ‹ä¸€ä¸‹è¯¥æ¼æ´çš„ç»†èŠ‚ å’Œ æè¿°, å‘ç°è¯¥æ¼æ´çš„åŸç†å…¶å®ååˆ†ç®€å•, å°±æ˜¯åœ¨ if s3Err != ErrNone åˆ¤æ–­ä¹‹åæ²¡æœ‰å°†ä¸åˆæ³•çš„æ§åˆ¶æµè¿”å›, è€Œæ˜¯ä»»ç”±å®ƒç»§ç»­è¿›å…¥æ¥ä¸‹å»çš„claims, s3Err := checkClaimsFromToken(r, cred), å¯¼è‡´æ ¡éªŒå¤±è´¥.\nå…·ä½“çš„æ¼æ´åˆ©ç”¨å¯ä»¥çœ‹è¿™é‡Œ\nPart 1: Letâ€™s catch the bug! 1.1: Finding references to ErrNone Write the query that finds all identifiers named ErrNone. You will find in the documentation the relevant object types to query. Your query should return 231 results.\nimport go from Ident i where i.getName() = \"ErrNone\" //Identå°±æ˜¯æ ‡è¯†ç¬¦ select i è¿è¡Œåå°±å¯ä»¥æ£€ç´¢å‡ºErrNoneå‡ºç°è¿‡çš„æ‰€æœ‰ä½ç½®.\n1.2: Finding equality tests against ErrNone In this next step, write a query to find all equality test expressions where one of the operands is an identifier called ErrNone. Your query should give you 158 results.\nimport go from EqualityTestExpr e where e.getAnOperand().(Ident).getName() = \"ErrNone\" select e EqualityTestExpræ˜¯ä¸€ä¸ªç­‰å¼æµ‹è¯•, ä¸º==æˆ–!=, å®ƒæ˜¯ä¸€ä¸ªExpression.\nåœ¨CodeQLä¸­, Expressionæ˜¯èƒ½è®¡ç®—ä¸ºä¸€ç»„å€¼å¹¶ä¸”å…·æœ‰ç±»å‹çš„è¯­å¥, æ¯”å¦‚1+1, \"QL\", [1,2,3,4,5].\nä¸ä¹‹å¯¹åº”çš„æ˜¯Statement, ä¾‹å¦‚tryè¯­å¥, ifè¯­å¥ç­‰ç­‰. statementæ²¡æœ‰è¿”å›å€¼, è€Œexpressionæ˜¯æœ‰è¿”å›å€¼çš„.\ne.getAnOperand().(Ident).getName() è¿™å—æ˜¯å…ˆä»EqualityTestExprä¸­è·å–æ“ä½œæ•°, ç„¶åè¿›è¡Œç±»å‹è½¬æ¢åè¿›è¡ŒæŸ¥çœ‹.\n1.3: Finding if-blocks making such a test Write a query that finds all if statements, where the condition is an equality test similar as found in step 1.2. Your query should give you 133 results.\nimport go from IfStmt s where s.getCond().(EqualityTestExpr).getAnOperand().(Ident).getName() = \"ErrNone\" select s ä»ä¹‹å‰çš„EqualityTestExpræ›¿æ¢ä¸ºäº†IfStmt, ç¼©å°äº†èŒƒå›´.\n1.4: Finding return statements Write a query that finds all return statements. Your query should give 10,651 results.\nimport go from ReturnStmt r select r å¯ä»¥çœ‹å‡ºæ¥codeqlæ”¯æŒè¯†åˆ«çš„statementç§ç±»è¿˜æŒºå¤šçš„.\n1.5: Finding if-blocks without return statements Write a query that finds all if-blocks that donâ€™t contain return statements in their then branch. Your query should return 3541 results. Remember, we are doing baby steps! We just care about the then branch for now!\nè¦æ‰¾æ‰€æœ‰if-blockä¸­ä¸åŒ…å«è¿”å›è¯­å¥çš„.\nimport go from IfStmt i where not i.getThen().getAStmt() instanceof ReturnStmt select i è¿™é‡Œi.getThen().getAStmt()æ˜¯ä»içš„thenåˆ†æ”¯ä¸­è·å–ä¸€ä¸ªstatement, æŒ‰ç†æ¥è¯´å¹¶ä¸ç¡®å®šè¿™ä¸ªstatementæ˜¯å¦æœ¬åº”è¯¥æ˜¯è¿”å›è¯­å¥, æ¯•ç«Ÿå³ä¾¿å­˜åœ¨ReturnStmt, ä¹Ÿå¯èƒ½æ²¡æœ‰è¢«getAStmtè·å–åˆ°. ç„¶è€Œå…³é”®åœ¨äºè¿™ä¸ªnot, å®ƒå’Œä¸ç­‰äºæœ‰ç€å®Œå…¨ä¸åŒçš„å«ä¹‰:\nA != B holds if there is a pair of values (one from A and one from B) that are different. not A = B holds if it is not the case that there is a pair of values that are the same. In other words, A and B have no values in common. è‡³æ­¤å°±æ¯”è¾ƒæ¸…æ¥šäº†\n1.6: Putting it all together Ok, time to find our bug! Combine steps 1.5 and 1.3 and write a query that finds the if-blocks testing for equality to ErrNone with no return. You should get a total of 7 results. Check that the bug weâ€™re looking for is one of them\nimport go from IfStmt i where i.getCond().(EqualityTestExpr).getAnOperand().(Ident).getName() = \"ErrNone\" and not i.getThen().getAStmt() instanceof ReturnStmt select i å°†ä¸Šé¢çš„ç»“åˆå°±å¯ä»¥äº†.\nè‡³æ­¤, å·²ç»å¯ä»¥æ£€æµ‹å‡ºæºå¸¦æ¼æ´ç‰¹å¾çš„ifä»£ç æ‰€åœ¨çš„ä½ç½®äº†.\nPart 2: Improving the precision ä¸Šè¿°codeqlçš„æŸ¥è¯¢ç»“æœä¸­å­˜åœ¨ä¸€äº›è¯¯æŠ¥. ä¸ºäº†å‡å°‘è¯¯æŠ¥, è€ƒè™‘ä½¿ç”¨æ›´ç²¾ç¡®çš„æ•°æ®æµåˆ†ææ¥æ£€æŸ¥isReqAuthenticatedçš„è¿”å›å€¼.\n2.1: Find conditionals that are fed from calls to isReqAuthenticated Write a data flow configuration that tracks data flowing from any call to isReqAuthenticated to any equality test operand. Your query must select all equality tests â€“ Type: DataFlow::EqualityTestNode â€“ where the operand is a sink of the above configuration.\nThis gives us 64 potentially interesting conditionals to investigate. Note many of them are not direct calls to isReqAuthenticated, instead they test the result of some intermediate function which in turn calls isReqAuthenticated. The CodeQL global data flow analysis feature allows us to detect those.\nimport go class AuthTestConfig extends DataFlow::Configuration { AuthTestConfig() { this = \"auth-test-config\" } override predicate isSource(DataFlow::Node source) { source = any(DataFlow::CallNode cn | cn.getTarget().hasQualifiedName(\"github.com/minio/minio/cmd\", \"isReqAuthenticated\") ).getResult() } override predicate isSink(DataFlow::Node sink) { sink = any(DataFlow::EqualityTestNode n).getAnOperand() } } from AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison where config.hasFlow(_, sink) and comparison.getAnOperand() = sink select comparison å“‡å¡, æ˜¯ä¼ è¯´ä¸­çš„æ±¡ç‚¹åˆ†æ! å…¶å®ä¸¥æ ¼æ„ä¹‰ä¸Šä¸ç®—æ˜¯, è¿™ä¸ªç®—æ˜¯æ•°æ®æµè·Ÿè¸ª.\nAuthTestConfigå®šä¹‰äº†æ•°æ®æµé…ç½®, å…¶ä¸­isSourceå’ŒisSinkåˆ†åˆ«å®šä¹‰äº†æ±¡ç‚¹åˆ†æä¸­çš„æ•°æ®æµèµ·ç‚¹Sourceå’Œæ•°æ®æµç»ˆç‚¹Sink. è¿™é‡ŒSourceä¸ºè°ƒç”¨isReqAuthenticatedå‡½æ•°çš„èŠ‚ç‚¹, Sinkæ˜¯æ¯”è¾ƒæµ‹è¯•èŠ‚ç‚¹ä¸­çš„æ“ä½œæ•°.\næ ¹æ®æ–‡æ¡£, anyè¿™ç©æ„çš„ç”¨æ³•å¦‚ä¸‹\nany( | | ) æ˜¯å¯¹variableçš„è¦æ±‚, å¯¹äºæ¯ä¸€ä¸ªæ»¡è¶³è¦æ±‚çš„å˜é‡éƒ½ä¼šè¿”å›ä¸€ä¸ª, å¦‚æœæ²¡æœ‰å°±è¿”å›variableæœ¬èº«, å› æ­¤å¯èƒ½ä¼šè¿”å›å¤šä¸ª.\né‚£ä¹ˆé—®é¢˜æ¥äº†, sourceæˆ–è€…sinkæ˜¯æ€ä¹ˆå’Œanyçš„å¤šä¸ªè¿”å›å€¼è¿›è¡Œæ¯”è¾ƒçš„å‘¢? å…¶å®ç­”æ¡ˆåœ¨æ–‡æ¡£ä¸­å·²ç»æè¿°äº†:\nFor expressions A and B, the formula A = B holds if there is a pair of valuesâ€”one from A and one from Bâ€”that are the same. In other words, A and B have at least one value in common. For example, [1 .. 2] = [2 .. 5] holds, since both expressions have the value 2.\nå› æ­¤, æ ¹æ®æ–‡æ¡£, 1 = [1..2] æ˜¯æˆç«‹çš„, é‚£ä¹ˆisSourceå’ŒisSinkä¸­çš„æ¯”è¾ƒä¹Ÿæ˜¯æˆç«‹çš„.\næœ€å, config.hasFlow(_, sink) ä¸­å°†sourceéƒ¨åˆ†è®¾ç½®ä¸º_, å› ä¸ºæˆ‘ä»¬çš„æŸ¥è¯¢ä¸­å¹¶ä¸åŒ…å«source, è€Œcomparison.getOperand() = sinkä¹Ÿæ˜¯æ–¹ä¾¿å»æŸ¥è¯¢å‡ºç›¸åº”çš„æ¯”è¾ƒæµ‹è¯•èŠ‚ç‚¹.\n2.2: Find the true bug! We can now put this dataflow query together with our query from step 1.6, and find all if statements that\nAre one of the equality tests returned in 2.1 Are testing equality against ErrNone Do not contain a return statement in their then branch import go class AuthTestConfig extends DataFlow::Configuration { AuthTestConfig() { this = \"auth-test-config\" } override predicate isSource(DataFlow::Node source) { source = any(DataFlow::CallNode cn | cn.getTarget().hasQualifiedName(\"github.com/minio/minio/cmd\", \"isReqAuthenticated\") ).getResult() } override predicate isSink(DataFlow::Node sink) { sink = any(DataFlow::EqualityTestNode n).getAnOperand() } } EqualityTestExpr getAnAuthCheck() { exists(AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison | config.hasFlow(_, sink) and comparison.getAnOperand() = sink | result = comparison.asExpr() ) } from IfStmt i where i.getCond() = getAnAuthCheck() and i.getCond().(EqualityTestExpr).getAnOperand().(Ident).getName() = \"ErrNone\" and not i.getThen().getAStmt() instanceof ReturnStmt select i å°†ä¹‹å‰çš„éƒ¨åˆ†ç»“åˆèµ·æ¥å°±å¯ä»¥äº†. è¿™é‡Œæ–°å‡ºç°äº†ä¸€ä¸ªexists, å…¶ç”¨æ³•ä¸º:\nexists( | ) å½“å­˜åœ¨ä¸€ä¸ªå˜é‡ä½¿å¾—formulaæˆç«‹, å…¬å¼æˆç«‹, è€Œformulaå¯ä»¥æœ‰å¤šä¸ª, å³\nexists( | | |...| ) ç­‰ä»·äº\nexists( | and and...and ) å¦‚æœè‡³å°‘å­˜åœ¨ä¸€ç»„variablesä½¿å¾—å…¨éƒ¨formulaéƒ½æ»¡è¶³, é‚£ä¹ˆå…¬å¼æˆç«‹.\nè€Œé¢˜è§£ä¸­çš„è¿™ç§å†™æ³•, ç›¸å½“äºç­‰å‰é¢æ‰€æœ‰çš„formulaéƒ½æ»¡è¶³çš„æ—¶å€™, ä¸´æ—¶å˜é‡resultä¼šè¢«èµ‹å€¼ comparison.asExpr() , è€Œresultåˆæ˜¯ getAnAuthCheck çš„è¿”å›å€¼, å› æ­¤å°±å˜æˆ: è¿”å›ä¸€ç»„æ»¡è¶³è¿ç®—å•å…ƒæ˜¯æ±¡ç‚¹æºçš„ EqualityTestExpr.\nPart 3: Expanding the query è¿™éƒ¨åˆ†è¦æ‰©å¤§èŒƒå›´, ä¸å†å±€é™äºMinIOäº†, ä½¿ç”¨çš„æ£€æµ‹å¯¹è±¡æ˜¯è¿™é“é¢˜ç›®é™„å¸¦çš„database.\n3.1: Conditional polarity You might have noticed this in step 1.6: our code looking for equality tests encompases both x == ErrNone and x != ErrNone and checks the then block in both cases. This is wrong. It ought to check the â€œthenâ€ or â€œelseâ€ case of an if block, depending on which form of conditional is used. Modify your query to fix this problem. Your query should be able to detect all bad examples in conditionalPolarities.go. Hint: Check out the predicate EqualityTestExpr.getPolarity\néœ€è¦æ ¹æ®x==ErrNoneå’Œx!=ErrNoneçš„ä¸åŒæƒ…å†µè¿›è¡Œä¸åŒæ£€æŸ¥.\nimport go class AuthTestConfig extends DataFlow::Configuration { AuthTestConfig() { this = \"auth-test-config\" } override predicate isSource(DataFlow::Node source) { source = any(DataFlow::CallNode cn | cn.getTarget().hasQualifiedName(\"github.com/minio/minio/cmd\", \"isReqAuthenticated\") or // Note new source function: cn.getTarget().hasQualifiedName(\"github.com/github/codeql-ctf-go-return\", \"errorSource\") ).getResult() } override predicate isSink(DataFlow::Node sink) { sink = any(DataFlow::EqualityTestNode n).getAnOperand() } } EqualityTestExpr getADirectAuthCheck(boolean polarity) { exists(AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison | config.hasFlow(_, sink) and comparison.getAnOperand() = sink | result = comparison.asExpr() and polarity = result.getPolarity() ) } /** * Given `ifStmt`'s condition compares some `x` against `ErrNone` with `polarity` (true means checking * equality; false checking inequality), return the block reached when `x != ErrNone`. */ BlockStmt getErrorBranch(IfStmt ifStmt, boolean polarity) { polarity = [true, false] and if polarity = true then result = ifStmt.getElse() else result = ifStmt.getThen() } from IfStmt i, boolean testPolarity where i.getCond() = getADirectAuthCheck(testPolarity) and i.getCond().(EqualityTestExpr).getAnOperand().(Ident).getName() = \"ErrNone\" and not getErrorBranch(i, testPolarity).getAStmt() instanceof ReturnStmt select i é‡ç‚¹æ˜¯if polarity = true then result = ifStmt.getElse() else result = ifStmt.getThen()è¿™ä¸€å¥.\nå¦å¤–polarity = [true, false]è¿™ä¸ªæ˜¯å¯¹å˜é‡çš„é™åˆ¶, åœ¨æ–‡æ¡£ä¸­æœ‰ç›¸å…³çš„æè¿°\nIt must be possible to evaluate a predicate in a finite amount of time, so the set it describes is not usually allowed to be infinite. In other words, a predicate can only contain a finite number of tuples.\nå¦‚æœæ²¡æœ‰polarity = [true, false], è™½ç„¶ç†è®ºä¸Šæ¥è¯´booleanå˜é‡ä¹Ÿåªæœ‰ä¸¤ä¸ªå€¼, ä½†æ˜¯ç»Ÿä¸€èµ·è§è¿˜æ˜¯éœ€è¦åšé™åˆ¶.\n3.2: More blocks Letâ€™s detect more blocks that must return. For example, our query fails to detect a return statement in an else branch, and there are other such cases that we need to handle, such as cascading else or switch/case. Modify your query to find more blocks that donâ€™t return. Your query should be able to detect all bad examples in moreWaysToReturn.go. Hints: While we could recursively inspect the control-flow structures inside the if block, it may help to use the control-flow graph. Check the documentation of the class IR::ReturnInstruction, a control-flow graph node corresponding to a return statement, and the getAPredecessor() / getASuccessor() methods of its superclass ControlFlow::Node, which traverse control-flow graph edges. A passing or failing if test is always followed by a ConditionGuardNode that indicates which branch was taken.\nTip: Try creating a temporary query such as the one below to get an idea what the control flow graph looks like.\nfrom ControlFlow::Node pred, ControlFlow::Node succ where succ = pred.getASuccessor() // you can also restrict `pred` to come from a particular source file select pred, succ è¦å¯»æ‰¾æ›´å¤šåˆ†æ”¯è¯­å¥ä¸­çš„æ²¡æœ‰è¿”å›çš„éƒ¨åˆ†.\nimport go class AuthTestConfig extends DataFlow::Configuration { AuthTestConfig() { this = \"auth-test-config\" } override predicate isSource(DataFlow::Node source) { source = any(DataFlow::CallNode cn | cn.getTarget().hasQualifiedName(\"github.com/minio/minio/cmd\", \"isReqAuthenticated\") or cn.getTarget().hasQualifiedName(\"github.com/github/codeql-ctf-go-return\", \"errorSource\") ).getResult() } override predicate isSink(DataFlow::Node sink) { sink = any(DataFlow::EqualityTestNode n).getAnOperand() } } EqualityTestExpr getAnAuthCheck() { exists(AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison | config.hasFlow(_, sink) and comparison.getAnOperand() = sink | result = comparison.asExpr() ) } ReturnStmt getAReturnStatementInBlock(BlockStmt b) { result = b.getAChild*() } predicate mustReachReturnInBlock(ControlFlow::Node node, BlockStmt b) { node.(IR::ReturnInstruction).getReturnStmt() = getAReturnStatementInBlock(b) or forex(ControlFlow::Node succ | succ = node.getASuccessor() | mustReachReturnInBlock(succ, b)) } from IfStmt i, ControlFlow::ConditionGuardNode ifSucc where i.getCond() = getAnAuthCheck() and i.getCond().(EqualityTestExpr).getAnOperand().(Ident).getName() = \"ErrNone\" and ifSucc.ensures(DataFlow::exprNode(i.getCond()), true) and not mustReachReturnInBlock(ifSucc, i.getThen()) select i ifSucc.ensures(DataFlow::exprNode(i.getCond()), true) æ¶‰åŠåˆ°äº†æ§åˆ¶æµèŠ‚ç‚¹ifSucc, è¿™æ¡è¯­å¥çš„æ„æ€æ˜¯ ç¡®ä¿i.getCond()çš„æ¡ä»¶æˆç«‹, æˆç«‹ä¹‹åæ‰å¯¹thenåˆ†æ”¯çš„è¯­å¥è¿›è¡Œåˆ†æ.\nå…³äºConditionGuardNode, æ–‡æ¡£ä¸­çš„æœ‰ç›´è§‚çš„å®ä¾‹.\nå¯¹äºä»¥ä¸‹ä»£ç \nx := 0 if p != nil { x = p.f } return x å…¶ConditionGuardNodeä¸ºå›¾ä¸­çš„p != nil is trueå’Œp != nil is false.\nå½“å˜é‡è°ƒç”¨è°“è¯(predicate)çš„æ—¶å€™, å¦‚æœå­˜åœ¨ç»“æœ, é‚£ä¹ˆè¿™ç§è°ƒç”¨æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼, å¦åˆ™å°±æ˜¯ä¸€ä¸ªå…¬å¼. è¿”å›ç»“æœçš„è°“è¯å¯ä»¥åœ¨ç»è¿‡é€»è¾‘åˆ¤æ–­åè¿”å›å¤šä¸ªç»“æœ, ä¾‹å¦‚\nstring getANeighbor(string country) { country = \"France\" and result = \"Belgium\" or country = \"France\" and result = \"Germany\" or country = \"Germany\" and result = \"Austria\" or country = \"Germany\" and result = \"Belgium\" } å¯¹äºä¸Šè¿°predicate, å¦‚æœcountryä¸º\"Germany\", é‚£ä¹ˆè¿”å›å€¼ä¸ºAustriaå’ŒBelgium, è¿™ç‚¹å’Œå¹³æ—¶ç”¨çš„ç¼–ç¨‹è¯­è¨€åŒºåˆ«æŒºå¤§çš„.\nåŒæ ·çš„, b.getAChild()æ˜¯ä¸€ä¸ªå¸¦ç»“æœçš„è°“è¯è°ƒç”¨, ä¼šè¿”å›å¤šä¸ªå­èŠ‚ç‚¹.\næ¥ä¸‹æ¥æ˜¯ä»£è¡¨é—­åŒ…ä¼ é€’çš„*å’Œ+, è¿™ä¸¤ä¸ªéƒ½æœ‰è¿­ä»£çš„åŠŸèƒ½, ä¾‹å¦‚ReturnStmt getAChild*() ç­‰ä»·äº\nReturnStmt getOneChild() { result = this or result = this.getAChild().getOneChild() } è€ŒReturnStmt getAChild+() ç­‰ä»·äº\nReturnStmt getOneChild() { result = this.getAChild() or result = this.getAChild().getOneChild() } ä¹Ÿå°±æ˜¯è¯´*ç›¸æ¯”è¾ƒ+è¿˜åŒ…å«äº†è‡ªèº«.\né‚£ä¹ˆgetAReturnStatementInBlockçš„ç»“æœå°±æ˜¯å½“å‰èŠ‚ç‚¹åŠ ä¸Šå½“å‰èŠ‚ç‚¹ç»è¿‡é€’å½’åçš„æ‰€æœ‰å­èŠ‚ç‚¹.\né‚£ä¹ˆå­èŠ‚ç‚¹çš„é›†åˆè¦æ€ä¹ˆå’Œnode.(IR::ReturnInstruction).getReturnStmt()è¿›è¡Œæ¯”è¾ƒ? æ ¹æ®æ–‡æ¡£ä¸­æ‰€æè¿°çš„:\nFor expressions A and B, the formula A = B holds if there is a pair of valuesâ€”one from A and one from Bâ€”that are the same. In other words, A and B have at least one value in common. For example, [1 .. 2] = [2 .. 5] holds, since both expressions have the value 2.\né‚£ä¹ˆå°±ä¸éš¾ç†è§£äº†, åªè¦node.(IR::ReturnInstruction).getReturnStmt()çš„å€¼å’Œå…¶ä¸­ä¸€ä¸ªç›¸åŒ, mustReachReturnInBlockå°±ä¼šæˆç«‹, ä¸ç„¶å°±è¿›å…¥forexéƒ¨åˆ†.\nforexçš„ç”¨æ³•, æ ¹æ®æ–‡æ¡£, å¯ä»¥çœ‹ä½œæ˜¯forall å’Œ exists çš„ç»“åˆ. ä¸‰è€…çš„å®šä¹‰å¦‚ä¸‹\nforall( | | ) forex( | | ) ç­‰ä»·äº forall( | | ) and exists( | | ) forall: å½“æ¯ä¸€ä¸ªè®©formula1 æˆç«‹çš„å˜é‡åœ¨formula2æˆç«‹çš„æ—¶å€™, å…¬å¼æˆç«‹ forex: å’Œforallç±»ä¼¼, ä½†æ˜¯æ’é™¤äº†ä¸å­˜åœ¨æ»¡è¶³formula1çš„å˜é‡çš„æƒ…å†µ, å› ä¸ºè¿™ç§æƒ…å†µä¸‹formula2ä¼šæ— æ¡ä»¶æˆç«‹. é‚£ä¹ˆä»£ç ä¸­forexçš„æ„æ€å°±æ˜¯: å¯¹äºnodeçš„successor, è¦æ±‚successorå­˜åœ¨, å¹¶ä¸”æ¯ä¸€ä¸ªsuccessoræ»¡è¶³mustReachReturnInBlock, ä¹Ÿå°±æ˜¯è¯´æ¯ä¸€ä¸ªsuccessoréƒ½å­˜åœ¨ReturnStmt\nåœ¨æŸ¥é˜…æ–‡æ¡£çš„æ—¶å€™å¯ä»¥æ³¨æ„ç±»çš„supertypeséƒ½æœ‰å“ªäº›, åŒ…æ‹¬Direct supertypes å’Œ Indirect supertypes. æ‰€è°“Indirect supertypeså°±æ˜¯æŒ‡, supertypeåœ¨ç»å†äº†å¤šæ¬¡ç»§æ‰¿ä¹‹åæ‰èƒ½å˜æˆè¯¥ç±», è€Œdirect supertypes æ˜¯ç›´æ¥ç»§æ‰¿çš„. è¿™äº›supertypeséƒ½å¯ä»¥é€šè¿‡ç±»å‹è½¬æ¢å˜æˆè¿™ä¸ªç±».\n3.3: Wrapped conditionals Now we can have cases where our equality test against ErrNone is no longer directly used in a conditional statement, but is instead wrapped inside a utility function. Modify your query to handle this case. Your query should be able to detect all bad examples in wrapperFunctions.go.\nHint:\nYou can have several layers in your wrap! Check out the predicates CallExpr::getTarget(), DataFlow::CallNode::getTarget() and Function::getFuncDecl() to navigate between a callsite and its callee. ç›¸æ¯”è¾ƒä¹‹å‰çš„ç›´æ¥æŸ¥è¯¢ifè¯­å¥ä¸­çš„å†…å®¹, è¿™é‡Œè¦æ±‚é¢å¤–è¦†ç›–ä½¿ç”¨å‡½æ•°è¿”å›å€¼è¿›è¡Œåˆ¤æ–­çš„æƒ…å†µ, ä¾‹å¦‚\nif succeeded(errorSource()) { doSomething() } else { // Bad: despite an error, we carry on to execute doSomething() insteadOfReturn() } import go class AuthTestConfig extends DataFlow::Configuration { AuthTestConfig() { this = \"auth-test-config\" } override predicate isSource(DataFlow::Node source) { source = any(DataFlow::CallNode cn | cn.getTarget().hasQualifiedName(\"github.com/minio/minio/cmd\", \"isReqAuthenticated\") or // Note new source function: cn.getTarget().hasQualifiedName(\"github.com/github/codeql-ctf-go-return\", \"errorSource\") ).getResult() } override predicate isSink(DataFlow::Node sink) { sink = any(DataFlow::EqualityTestNode n).getAnOperand() } } EqualityTestExpr getADirectAuthCheck(boolean polarity) { exists(AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison | config.hasFlow(_, sink) and comparison.getAnOperand() = sink | result = comparison.asExpr() and result.getAnOperand().(Ident).getName() = \"ErrNone\" and polarity = result.getPolarity() ) } CallExpr getACheckCall(boolean polarity, FuncDecl target, Expr innerCheck) { innerCheck = getAnAuthCheck(polarity) and target = result.getTarget().getFuncDecl() and forex(DataFlow::ResultNode rn | rn.getRoot() = target | rn.asExpr() = innerCheck) } Expr getAnAuthCheck(boolean polarity) { result = getADirectAuthCheck(polarity) or result = getACheckCall(polarity, _, _) } /** * Given `ifStmt`'s condition compares some `x` against `ErrNone` with `polarity` (true means checking * equality; false checking inequality), return the block reached when `x != ErrNone`. */ BlockStmt getErrorBranch(IfStmt ifStmt, boolean polarity) { polarity = [true, false] and if polarity = true then result = ifStmt.getElse() else result = ifStmt.getThen() } from IfStmt i, boolean testPolarity where i.getCond() = getAnAuthCheck(testPolarity) and not getErrorBranch(i, testPolarity).getAStmt() instanceof ReturnStmt select i getErrorBranch æ²¡ä»€ä¹ˆå¥½è¯´çš„, å°±æ˜¯æ ¹æ®polarityé€‰æ‹©elseåˆ†æ”¯æˆ–è€…thenåˆ†æ”¯.\nä½†æ˜¯getAnAuthCheckå°±ä¸åŒäº†, è¿™é‡Œç”¨åˆ°äº†ä¸€ä¸ªç›¸å½“é«˜çº§çš„å†™æ³•: ç›¸äº’é€’å½’(Mutal Recursion), è¿™ä¼šå½¢æˆè°“è¯ä¹‹é—´çš„ä¾èµ–é“¾æ¡, å¯ä»¥çœ‹æ–‡æ¡£ ç»™å‡ºçš„ä¸€ä¸ªä¾‹å­.\nint getAnEven() { result = 0 or result \u003c= 100 and result = getAnOdd() + 1 } int getAnOdd() { result = getAnEven() + 1 } select getAnEven() åœ¨è¿™ä¸ªä¾‹å­ä¸­getAnEvenå’ŒgetAnOddä¹‹é—´å½¢æˆäº†è°“è¯ä¾èµ–é“¾æ¡, codeqlä¼šæŒç»­é€’å½’åˆ°é™åˆ¶æ¡ä»¶åè¿”å›0åˆ°100çš„å¶æ•°.\ngetAnAuthCheckå’ŒgetACheckCallä¹‹é—´ä¹Ÿå­˜åœ¨ç›¸äº’é€’å½’çš„å…³ç³». getAnAuthCheck é¦–å…ˆæ ¹æ®polarityçš„å€¼å»é€‰æ‹©xxx==ErrNoneæˆ–xxx!=ErrorNoneè¿™ä¸¤ç§sinkå¹¶è½¬åŒ–ä¸ºè¡¨è¾¾å¼, å’Œä¹‹å‰çš„å·®ä¸å¤š, è€ŒgetACheckCallä¸­, é¦–å…ˆä¼šåè¿‡æ¥é€’å½’è·å–getAnAuthCheckçš„ç»“æœ.\nå®šä¹‰targetä¸ºå‡½æ•°çš„å£°æ˜, åŒæ—¶ä¹Ÿå¯¹CallExprç±»å‹çš„resultä½œäº†éšå¼çš„å®šä¹‰.\næ¥ä¸‹æ¥, forexå¯¹æ¯ä¸€ä¸ªDataFlow::ResultNode è¿›è¡Œæ£€æŸ¥, DataFlow::ResultNode åœ¨æ–‡æ¡£ä¸­æè¿°ä¸º:\nThis can either be a node corresponding to an expression in a return statement, or a node representing the current value of a named result variable at the exit of the function.\nè€ŒgetRootèƒ½å¤Ÿè·å–èŠ‚ç‚¹æ‰€å±çš„å‡½æ•°, è¿™ä¸ªforexçš„æ„æ€å°±æˆä¸ºäº† è¦æ±‚æ¯ä¸€ä¸ªResultNodeæ‰€å±çš„å‡½æ•°éƒ½ä¸targetä»£è¡¨çš„å‡½æ•°å¯¹åº”, åŒæ—¶ResultNodeçš„è¡¨è¾¾å¼æ˜¯getAnAuthCheckçš„ç»“æœ, ä¹Ÿå°±æ˜¯innerCheck\né‚£ä¹ˆinnerCheckä¹Ÿå°±æ˜¯getAnAuthCheck(polarity), ä»£è¡¨çš„å°±æ˜¯æ¡ä»¶åˆ¤æ–­çš„sink, ä»¥åŠæ¡ä»¶åˆ¤æ–­ä¸­æ‰€ä½¿ç”¨çš„å­˜åœ¨æ¡ä»¶åˆ¤æ–­sinkçš„å‡½æ•°.\n3.4: More conditionals Our code works for simple equality tests, but there are cases where this test is part of a bigger test with conditionals involving !, \u0026\u0026, ||, that are not currently accounted for in our query. Improve your query to handle these cases. Your query should be able to detect all bad examples in logicalOperators.go. Hint: Check out ControlFlow::ConditionGuardNode. This node flags a point in a control-flow graph where a particular test is known to have passed or failed, including those nested within the short-circuiting binary logical operators \u0026\u0026, ||. Its predicate ensures can already analyse some boolean expression structure. Even if you cannot use it directly, the implementation of ensures may be a useful inspiration for your solution. See the hints for Step 3.2 for more information about the control-flow graph.\nä¹Ÿå°±æ˜¯è¯´è¦å¯¹!x, x||y, x \u0026\u0026 y, (x) è¿™äº›æƒ…å†µè¿›è¡Œå¤„ç†.\nimport go class AuthTestConfig extends DataFlow::Configuration { AuthTestConfig() { this = \"auth-test-config\" } override predicate isSource(DataFlow::Node source) { source = any(DataFlow::CallNode cn | cn.getTarget().hasQualifiedName(\"github.com/minio/minio/cmd\", \"isReqAuthenticated\") or // Note new source function: cn.getTarget().hasQualifiedName(\"github.com/github/codeql-ctf-go-return\", \"errorSource\") ).getResult() } override predicate isSink(DataFlow::Node sink) { sink = any(DataFlow::EqualityTestNode n).getAnOperand() } } EqualityTestExpr getADirectAuthCheck(boolean polarity) { exists(AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison | config.hasFlow(_, sink) and comparison.getAnOperand() = sink | result = comparison.asExpr() and polarity = result.getPolarity() ) } Expr getAnAuthCheck(Boolean noError, EqualityTestExpr test) { result = getADirectAuthCheck(noError) and test = result or result.(ParenExpr).getExpr() = getAnAuthCheck(noError, test) or result.(NotExpr).getOperand() = getAnAuthCheck(noError.booleanNot(), test) or result.(LandExpr).getRightOperand() = getAnAuthCheck(noError, test) or result.(LandExpr).getLeftOperand() = getAnAuthCheck(true, test) and noError = true or result.(LandExpr).getLeftOperand() = getAnAuthCheck(false, test) and noError = [true, false] or result.(LorExpr).getRightOperand() = getAnAuthCheck(noError, test) or result.(LorExpr).getLeftOperand() = getAnAuthCheck(false, test) and noError = false or result.(LorExpr).getLeftOperand() = getAnAuthCheck(true, test) and noError = [true, false] } BlockStmt getErrorBranch(IfStmt ifStmt, boolean polarity) { polarity = [true, false] and if polarity = true then result = ifStmt.getElse() else result = ifStmt.getThen() } from IfStmt i, EqualityTestExpr test where test.getAnOperand().(Ident).getName() = \"ErrNone\" and not forall(boolean testPolarity | i.getCond() = getAnAuthCheck(testPolarity, test) | exists(Stmt s | s = getErrorBranch(i, testPolarity).getAStmt() | s instanceof ReturnStmt)) and i.getFile().getBaseName() = \"logicalOperators.go\" select i getAnAuthCheckæ˜¯é‡ç‚¹\n// ä½¿ç”¨testæ¥çº¦æŸç›´æ¥æ£€æŸ¥çš„ç»“æœ: å¿…é¡»æ˜¯æœ‰ErrNoneå‚ä¸çš„ç­‰å¼æ£€æŸ¥ result = getADirectAuthCheck(noError) and result = test or // å¯¹getAnAuthCheckçš„ç»“æœè¿›è¡Œçº¦æŸ, ç»“æœå¿…é¡»ä¸ºä¸€ä¸ªParenExprä¸­å»æ‰æ‹¬å·çš„Expr // å¦‚æœå­˜åœ¨è¿™æ ·çš„ç»“æœ, é‚£ä¹ˆè¿™é‡Œçš„resultå°±æ»¡è¶³è¦æ±‚äº† result.(ParenExpr).getExpr() = getAnAuthCheck(noError, test) or // å¯¹getAnAuthCheckçš„ç»“æœè¿›è¡Œçº¦æŸ, ç»“æœå¿…é¡»ä¸ºä¸€ä¸ªNotExprä¸­å»æ‰Notéƒ¨åˆ†çš„Expr result.(NotExpr).getOperand() = getAnAuthCheck(noError.booleanNot(), test) ä½†æ˜¯æ¥ä¸‹æ¥çš„é‚£å‡ ä¸ªANDå’ŒORç›¸å…³çš„å¤„ç†æˆ‘å°±çœ‹ä¸æ‡‚äº†, åç»­å†è¯´å§.\næœ€ååº”è¯¥è¯´æ˜ä¸€ä¸‹forallå’Œexistsçš„ç»„åˆä½¿ç”¨:\n// æ‰€æœ‰æ»¡è¶³æ±¡ç‚¹å’ŒErrNoneå‚ä¸çš„æ¡ä»¶æ£€æŸ¥ä¸­, æ¯ä¸€ä¸ªåˆ†æ”¯é‡Œéƒ½å­˜åœ¨è¿”å›è¯­å¥ forall(boolean testPolarity | i.getCond() = getAnAuthCheck(testPolarity, test) | // å¦‚æœé”™è¯¯åˆ†æ”¯ä¸­å­˜åœ¨è¿”å›è¯­å¥, é‚£ä¹ˆæˆç«‹ exists(Stmt s | s = getErrorBranch(i, testPolarity).getAStmt() | s instanceof ReturnStmt)) å°†ä¸Šé¢çš„é€»è¾‘å–å, å°±å˜æˆäº† æ‰€æœ‰æ»¡è¶³æ±¡ç‚¹å’ŒErrNoneå‚ä¸çš„æ¡ä»¶æ£€æŸ¥ä¸­, å­˜åœ¨ä¸åŒ…å«è¿”å›è¯­å¥çš„åˆ†æ”¯.\n3.5: Valid returns only Ok, so now we make sure we return something when we check the permission. But is that enough? Just returning somehow isnâ€™t good enough, we may also need to return an appropriate value. The use of non-nil / nil error values is normal to indicate an error in Go, so letâ€™s assume for this problem that non-nil is considered an appropriate return value. Modify your query to detect all bad examples in checkReturnValue.go.\néœ€è¦æ£€æµ‹é‚£äº›å’ŒErrNoneæ¯”è¾ƒåå¯èƒ½è¿”å›nilçš„æƒ…å†µ.\nimport go class AuthTestConfig extends DataFlow::Configuration { AuthTestConfig() { this = \"auth-test-config\" } override predicate isSource(DataFlow::Node source) { source = any(DataFlow::CallNode cn | cn.getTarget().hasQualifiedName(\"github.com/minio/minio/cmd\", \"isReqAuthenticated\") or // Note new source function: cn.getTarget().hasQualifiedName(\"github.com/github/codeql-ctf-go-return\", \"errorSource\") ).getResult() } override predicate isSink(DataFlow::Node sink) { sink = any(DataFlow::EqualityTestNode n).getAnOperand() } } predicate returnsNil(FuncDecl f) { forex(DataFlow::ResultNode r | r.getRoot() = f | r = Builtin::nil().getARead()) } predicate isNil(Expr e) { e = any(CallExpr c | returnsNil(c.getTarget().getFuncDecl())) or e = Builtin::nil().getAReference() } EqualityTestExpr getADirectAuthCheck(boolean polarity) { exists(AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison | config.hasFlow(_, sink) and comparison.getAnOperand() = sink | result = comparison.asExpr() and polarity = result.getPolarity() ) } /** * Given `ifStmt`'s condition compares some `x` against `ErrNone` with `polarity` (true means checking * equality; false checking inequality), return the block reached when `x != ErrNone`. */ BlockStmt getErrorBranch(IfStmt ifStmt, boolean polarity) { polarity = [true, false] and if polarity = true then result = ifStmt.getElse() else result = ifStmt.getThen() } from IfStmt i, boolean testPolarity, int resultIdx where i.getCond() = getADirectAuthCheck(testPolarity) and i.getCond().(EqualityTestExpr).getAnOperand().(Ident).getName() = \"ErrNone\" and i.getEnclosingFunction().getType().getResultType(resultIdx) = Builtin::error().getType() and // i æ‰€å±å‡½æ•°çš„è¿”å›å€¼ç±»å‹ä¸­æœ‰é”™è¯¯ç±»å‹ not exists(ReturnStmt r | r = getErrorBranch(i, testPolarity).getAStmt() | not isNil(r.getExpr(resultIdx)) ) // è¿™ä¸ªé”™è¯¯ç±»å‹ä¸æ˜¯nil select i ",
  "wordCount" : "2729",
  "inLanguage": "en",
  "image":"https://dragonbox.top/cover.png","datePublished": "2024-12-06T09:03:06+08:00",
  "dateModified": "2024-12-06T09:03:06+08:00",
  "author":{
    "@type": "Person",
    "name": "ch3n9w"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://dragonbox.top/posts/sec-codeql-ctf/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "ch3n9w ã® è¶…å…ƒåŸŸ",
    "logo": {
      "@type": "ImageObject",
      "url": "https://dragonbox.top/flash.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://dragonbox.top/" accesskey="h" title="ch3n9w ã® è¶…å…ƒåŸŸ (Alt + H)">
                <img src="https://dragonbox.top/avatar.jpg" alt="" aria-label="logo"
                    height="35">ch3n9w ã® è¶…å…ƒåŸŸ</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://dragonbox.top/categories/" title="categories">
                    <span>categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://dragonbox.top/">Home</a>&nbsp;Â»&nbsp;<a href="https://dragonbox.top/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      CodeQL CTF ä¹‹ Go and don&#39;t return
    </h1>
    <div class="post-meta"><span title='2024-12-06 09:03:06 +0800 CST'>December 6, 2024</span>&nbsp;Â·&nbsp;13 min&nbsp;Â·&nbsp;2729 words&nbsp;Â·&nbsp;ch3n9w

</div>
  </header> 
<figure class="entry-cover">
        <img loading="eager" srcset="https://dragonbox.top/posts/sec-codeql-ctf/cover_hu18341172239657117764.png 360w ,https://dragonbox.top/posts/sec-codeql-ctf/cover_hu3399689789567156695.png 480w ,https://dragonbox.top/posts/sec-codeql-ctf/cover_hu6462648450707173077.png 720w ,https://dragonbox.top/posts/sec-codeql-ctf/cover_hu196017312278354417.png 1080w ,https://dragonbox.top/posts/sec-codeql-ctf/cover.png 1200w" 
            sizes="(min-width: 768px) 720px, 100vw" src="https://dragonbox.top/posts/sec-codeql-ctf/cover.png" alt="" 
            width="1200" height="630">
        
</figure><div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#part-1-lets-catch-the-bug">Part 1: Letâ€™s catch the bug!</a>
      <ul>
        <li><a href="#11-finding-references-to-errnone">1.1: Finding references to ErrNone</a></li>
        <li><a href="#12-finding-equality-tests-against-errnone">1.2: Finding equality tests against ErrNone</a></li>
        <li><a href="#13-finding-if-blocks-making-such-a-test">1.3: Finding if-blocks making such a test</a></li>
        <li><a href="#14-finding-return-statements">1.4: Finding return statements</a></li>
        <li><a href="#15-finding-if-blocks-without-return-statements">1.5: Finding if-blocks without return statements</a></li>
        <li><a href="#16-putting-it-all-together">1.6: Putting it all together</a></li>
      </ul>
    </li>
    <li><a href="#part-2-improving-the-precision">Part 2: Improving the precision</a>
      <ul>
        <li><a href="#21-find-conditionals-that-are-fed-from-calls-to-isreqauthenticated">2.1: Find conditionals that are fed from calls to isReqAuthenticated</a></li>
        <li><a href="#22-find-the-true-bug">2.2: Find the true bug!</a></li>
      </ul>
    </li>
    <li><a href="#part-3-expanding-the-query">Part 3: Expanding the query</a>
      <ul>
        <li><a href="#31-conditional-polarity">3.1: Conditional polarity</a></li>
        <li><a href="#32-more-blocks">3.2: More blocks</a></li>
        <li><a href="#33-wrapped-conditionals">3.3: Wrapped conditionals</a></li>
        <li><a href="#34-more-conditionals">3.4: More conditionals</a></li>
        <li><a href="#35-valid-returns-only">3.5: Valid returns only</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="go-and-dont-return">Go and don&rsquo;t return<a hidden class="anchor" aria-hidden="true" href="#go-and-dont-return">#</a></h1>
<p>è¿™é“é¢˜ç›®ä»MinIOçš„ä¸€ä¸ªå·²å…¬å¼€çš„æœªæˆæƒè®¿é—®æ¼æ´å¼€å§‹, é€šè¿‡ç¼–å†™å¹¶æ…¢æ…¢å®Œå–„CodeQLè¯­å¥æ¥æ£€æµ‹è¯¥æ¼æ´åœ¨ä»£ç ä¸­çš„ä½ç½®. éšç€é¢˜ç›®çš„è¿›è¡Œ, é¢˜ç›®å°†ç›®æ ‡å°†æ‰©å±•åˆ°æ­¤ç±»æ¼æ´çš„å„ç§å˜ç§, éš¾åº¦é€æ¸åŠ æ·±, éå¸¸é€‚åˆç”¨æ¥å…¥é—¨å’Œå­¦ä¹ . æœ¬æ–‡æ˜¯ç”¨æ¥è®°å½•æˆ‘åœ¨é˜…è¯»å®˜æ–¹é¢˜è§£æ—¶çš„æ€è€ƒè¿‡ç¨‹, å› ä¸ºæˆ‘åœ¨Part2å°±å¡ä½å•¦hhhhhhh.</p>
<p><a href="https://securitylab.github.com/ctf/go-and-dont-return/">ğŸ”—åŸé¢˜ç›®é“¾æ¥</a></p>
<p><a href="https://securitylab.github.com/ctf/go-and-dont-return/answers/">ğŸ”—å®˜æ–¹å‚è€ƒé¢˜è§£é“¾æ¥</a></p>
<p>åœ¨å¼€å§‹ä¹‹å‰, å¯ä»¥æŸ¥çœ‹ä¸€ä¸‹è¯¥æ¼æ´çš„<a href="https://github.com/minio/minio/commit/4cd6ca02c7957aeb2de3eede08b0754332a77923">ç»†èŠ‚</a> å’Œ <a href="https://github.com/minio/minio/security/advisories/GHSA-xv4r-vccv-mg4w">æè¿°</a>, å‘ç°è¯¥æ¼æ´çš„åŸç†å…¶å®ååˆ†ç®€å•, å°±æ˜¯åœ¨ <code>if s3Err != ErrNone</code> åˆ¤æ–­ä¹‹åæ²¡æœ‰å°†ä¸åˆæ³•çš„æ§åˆ¶æµè¿”å›, è€Œæ˜¯ä»»ç”±å®ƒç»§ç»­è¿›å…¥æ¥ä¸‹å»çš„<code>claims, s3Err := checkClaimsFromToken(r, cred)</code>, å¯¼è‡´æ ¡éªŒå¤±è´¥.</p>
<p>å…·ä½“çš„æ¼æ´åˆ©ç”¨å¯ä»¥çœ‹<a href="https://github.com/cokeBeer/go-cves/blob/main/CVE-2020-11012/CVE-2020-11012.md">è¿™é‡Œ</a></p>
<h2 id="part-1-lets-catch-the-bug">Part 1: Letâ€™s catch the bug!<a hidden class="anchor" aria-hidden="true" href="#part-1-lets-catch-the-bug">#</a></h2>
<h3 id="11-finding-references-to-errnone">1.1: Finding references to ErrNone<a hidden class="anchor" aria-hidden="true" href="#11-finding-references-to-errnone">#</a></h3>
<blockquote>
<p>Write the query that finds all identifiers named ErrNone. You will find in the documentation the relevant object types to query. Your query should return 231 results.</p>
</blockquote>
<pre tabindex="0"><code class="language-ql" data-lang="ql">
import go

from Ident i
where i.getName() = &#34;ErrNone&#34; //Identå°±æ˜¯æ ‡è¯†ç¬¦
select i
</code></pre><p>è¿è¡Œåå°±å¯ä»¥æ£€ç´¢å‡ºErrNoneå‡ºç°è¿‡çš„æ‰€æœ‰ä½ç½®.</p>
<h3 id="12-finding-equality-tests-against-errnone">1.2: Finding equality tests against ErrNone<a hidden class="anchor" aria-hidden="true" href="#12-finding-equality-tests-against-errnone">#</a></h3>
<p>In this next step, write a query to find all equality test expressions where one of the operands is an identifier called ErrNone. Your query should give you 158 results.</p>
<pre tabindex="0"><code class="language-ql" data-lang="ql">import go

from EqualityTestExpr e
where e.getAnOperand().(Ident).getName() = &#34;ErrNone&#34;
select e
</code></pre><p><code>EqualityTestExpr</code>æ˜¯ä¸€ä¸ªç­‰å¼æµ‹è¯•, ä¸º<code>==</code>æˆ–<code>!=</code>, å®ƒæ˜¯ä¸€ä¸ªExpression.</p>
<p>åœ¨CodeQLä¸­, Expressionæ˜¯èƒ½è®¡ç®—ä¸ºä¸€ç»„å€¼å¹¶ä¸”å…·æœ‰ç±»å‹çš„è¯­å¥, æ¯”å¦‚<code>1+1</code>, <code>&quot;QL&quot;</code>, <code>[1,2,3,4,5]</code>.</p>
<p>ä¸ä¹‹å¯¹åº”çš„æ˜¯Statement, ä¾‹å¦‚tryè¯­å¥, ifè¯­å¥ç­‰ç­‰. <strong>statementæ²¡æœ‰è¿”å›å€¼, è€Œexpressionæ˜¯æœ‰è¿”å›å€¼çš„.</strong></p>
<p><code>e.getAnOperand().(Ident).getName()</code> è¿™å—æ˜¯å…ˆä»<code>EqualityTestExpr</code>ä¸­è·å–æ“ä½œæ•°, ç„¶åè¿›è¡Œç±»å‹è½¬æ¢åè¿›è¡ŒæŸ¥çœ‹.</p>
<h3 id="13-finding-if-blocks-making-such-a-test">1.3: Finding if-blocks making such a test<a hidden class="anchor" aria-hidden="true" href="#13-finding-if-blocks-making-such-a-test">#</a></h3>
<blockquote>
<p>Write a query that finds all if statements, where the condition is an equality test similar as found in step 1.2. Your query should give you 133 results.</p>
</blockquote>
<pre tabindex="0"><code class="language-ql" data-lang="ql">import go

from IfStmt s
where s.getCond().(EqualityTestExpr).getAnOperand().(Ident).getName() = &#34;ErrNone&#34;
select s
</code></pre><p>ä»ä¹‹å‰çš„EqualityTestExpræ›¿æ¢ä¸ºäº†IfStmt, ç¼©å°äº†èŒƒå›´.</p>
<h3 id="14-finding-return-statements">1.4: Finding return statements<a hidden class="anchor" aria-hidden="true" href="#14-finding-return-statements">#</a></h3>
<blockquote>
<p>Write a query that finds all return statements. Your query should give 10,651 results.</p>
</blockquote>
<pre tabindex="0"><code class="language-ql" data-lang="ql">import go

from ReturnStmt r
select r
</code></pre><p>å¯ä»¥çœ‹å‡ºæ¥codeqlæ”¯æŒè¯†åˆ«çš„statementç§ç±»è¿˜æŒºå¤šçš„.</p>
<h3 id="15-finding-if-blocks-without-return-statements">1.5: Finding if-blocks without return statements<a hidden class="anchor" aria-hidden="true" href="#15-finding-if-blocks-without-return-statements">#</a></h3>
<blockquote>
<p>Write a query that finds all if-blocks that donâ€™t contain return statements in their then branch. Your query should return 3541 results. Remember, we are doing baby steps! We just care about the then branch for now!</p>
</blockquote>
<p>è¦æ‰¾æ‰€æœ‰if-blockä¸­ä¸åŒ…å«è¿”å›è¯­å¥çš„.</p>
<pre tabindex="0"><code class="language-ql" data-lang="ql">import go

from IfStmt i
where not i.getThen().getAStmt() instanceof ReturnStmt
select i
</code></pre><p>è¿™é‡Œ<code>i.getThen().getAStmt()</code>æ˜¯ä»içš„thenåˆ†æ”¯ä¸­è·å–ä¸€ä¸ªstatement, æŒ‰ç†æ¥è¯´å¹¶ä¸ç¡®å®šè¿™ä¸ªstatementæ˜¯å¦<strong>æœ¬åº”è¯¥</strong>æ˜¯è¿”å›è¯­å¥, æ¯•ç«Ÿå³ä¾¿å­˜åœ¨ReturnStmt, ä¹Ÿå¯èƒ½æ²¡æœ‰è¢«<code>getAStmt</code>è·å–åˆ°. ç„¶è€Œå…³é”®åœ¨äºè¿™ä¸ª<code>not</code>, å®ƒå’Œä¸ç­‰äºæœ‰ç€å®Œå…¨ä¸åŒçš„å«ä¹‰:</p>
<ul>
<li><code>A != B</code> holds if there is a pair of values (one from A and one from B) that are different.</li>
<li><code>not A = B</code> holds if it is not the case that there is a pair of values that are the same. In other words, <strong>A and B have no values in common</strong>.</li>
</ul>
<p>è‡³æ­¤å°±æ¯”è¾ƒæ¸…æ¥šäº†</p>
<h3 id="16-putting-it-all-together">1.6: Putting it all together<a hidden class="anchor" aria-hidden="true" href="#16-putting-it-all-together">#</a></h3>
<blockquote>
<p>Ok, time to find our bug! Combine steps 1.5 and 1.3 and write a query that finds the if-blocks testing for equality to ErrNone with no return.
You should get a total of 7 results. Check that the bug we&rsquo;re looking for is one of them</p>
</blockquote>
<pre tabindex="0"><code class="language-ql" data-lang="ql">import go

from IfStmt i
where
i.getCond().(EqualityTestExpr).getAnOperand().(Ident).getName() = &#34;ErrNone&#34;
and not i.getThen().getAStmt() instanceof ReturnStmt
select i
</code></pre><p>å°†ä¸Šé¢çš„ç»“åˆå°±å¯ä»¥äº†.</p>
<p>è‡³æ­¤, å·²ç»å¯ä»¥æ£€æµ‹å‡ºæºå¸¦æ¼æ´ç‰¹å¾çš„ifä»£ç æ‰€åœ¨çš„ä½ç½®äº†.</p>
<h2 id="part-2-improving-the-precision">Part 2: Improving the precision<a hidden class="anchor" aria-hidden="true" href="#part-2-improving-the-precision">#</a></h2>
<p>ä¸Šè¿°codeqlçš„æŸ¥è¯¢ç»“æœä¸­å­˜åœ¨ä¸€äº›è¯¯æŠ¥. ä¸ºäº†å‡å°‘è¯¯æŠ¥, è€ƒè™‘ä½¿ç”¨æ›´ç²¾ç¡®çš„æ•°æ®æµåˆ†ææ¥æ£€æŸ¥<code>isReqAuthenticated</code>çš„è¿”å›å€¼.</p>
<p><img loading="lazy" src="./isReqAuthenticated.png" alt="isReqAuthenticated"  />
</p>
<h3 id="21-find-conditionals-that-are-fed-from-calls-to-isreqauthenticated">2.1: Find conditionals that are fed from calls to isReqAuthenticated<a hidden class="anchor" aria-hidden="true" href="#21-find-conditionals-that-are-fed-from-calls-to-isreqauthenticated">#</a></h3>
<blockquote>
<p>Write a data flow configuration that tracks data flowing from any call to isReqAuthenticated to any equality test operand. Your query must select all equality tests &ndash; Type: DataFlow::EqualityTestNode &ndash; where the operand is a sink of the above configuration.</p>
</blockquote>
<blockquote>
<p>This gives us 64 potentially interesting conditionals to investigate. Note many of them are not direct calls to isReqAuthenticated, instead they test the result of some intermediate function which in turn calls isReqAuthenticated. The CodeQL global data flow analysis feature allows us to detect those.</p>
</blockquote>
<pre tabindex="0"><code class="language-ql" data-lang="ql">import go

class AuthTestConfig extends DataFlow::Configuration {

  AuthTestConfig() { this = &#34;auth-test-config&#34; }

  override predicate isSource(DataFlow::Node source) {
    source = any(DataFlow::CallNode cn |
      cn.getTarget().hasQualifiedName(&#34;github.com/minio/minio/cmd&#34;, &#34;isReqAuthenticated&#34;)
    ).getResult()
  }

  override predicate isSink(DataFlow::Node sink) {
    sink = any(DataFlow::EqualityTestNode n).getAnOperand()
  }

}

from AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison
where config.hasFlow(_, sink) and comparison.getAnOperand() = sink
select comparison
</code></pre><p>å“‡å¡, <del>æ˜¯ä¼ è¯´ä¸­çš„æ±¡ç‚¹åˆ†æ!</del> å…¶å®ä¸¥æ ¼æ„ä¹‰ä¸Šä¸ç®—æ˜¯, è¿™ä¸ªç®—æ˜¯æ•°æ®æµè·Ÿè¸ª.</p>
<p><code>AuthTestConfig</code>å®šä¹‰äº†æ•°æ®æµé…ç½®, å…¶ä¸­<code>isSource</code>å’Œ<code>isSink</code>åˆ†åˆ«å®šä¹‰äº†æ±¡ç‚¹åˆ†æä¸­çš„æ•°æ®æµèµ·ç‚¹Sourceå’Œæ•°æ®æµç»ˆç‚¹Sink. è¿™é‡ŒSourceä¸ºè°ƒç”¨<code>isReqAuthenticated</code>å‡½æ•°çš„èŠ‚ç‚¹, Sinkæ˜¯æ¯”è¾ƒæµ‹è¯•èŠ‚ç‚¹ä¸­çš„æ“ä½œæ•°.</p>
<p>æ ¹æ®<a href="https://codeql.github.com/docs/ql-language-reference/expressions/#any">æ–‡æ¡£</a>, <code>any</code>è¿™ç©æ„çš„ç”¨æ³•å¦‚ä¸‹</p>
<pre tabindex="0"><code>any(&lt;variable declarations&gt; | &lt;formula&gt; | &lt;expression&gt;)
</code></pre><p><code>&lt;formula&gt;</code>æ˜¯å¯¹variableçš„è¦æ±‚, å¯¹äºæ¯ä¸€ä¸ªæ»¡è¶³è¦æ±‚çš„å˜é‡éƒ½ä¼šè¿”å›ä¸€ä¸ª<code>&lt;expressions&gt;</code>, å¦‚æœæ²¡æœ‰<code>&lt;expressions&gt;</code>å°±è¿”å›variableæœ¬èº«, å› æ­¤å¯èƒ½ä¼šè¿”å›å¤šä¸ª.</p>
<p>é‚£ä¹ˆé—®é¢˜æ¥äº†, sourceæˆ–è€…sinkæ˜¯æ€ä¹ˆå’Œanyçš„å¤šä¸ªè¿”å›å€¼è¿›è¡Œæ¯”è¾ƒçš„å‘¢? å…¶å®ç­”æ¡ˆåœ¨<a href="https://codeql.github.com/docs/ql-language-reference/formulas/#equality-1">æ–‡æ¡£</a>ä¸­å·²ç»æè¿°äº†:</p>
<blockquote>
<p>For expressions A and B, the formula A = B holds if there is a pair of valuesâ€”one from A and one from Bâ€”that are the same. In other words, A and B have at least one value in common. For example, [1 .. 2] = [2 .. 5] holds, since both expressions have the value 2.</p>
</blockquote>
<p>å› æ­¤, æ ¹æ®æ–‡æ¡£, <code>1 = [1..2]</code> æ˜¯æˆç«‹çš„, é‚£ä¹ˆ<code>isSource</code>å’Œ<code>isSink</code>ä¸­çš„æ¯”è¾ƒä¹Ÿæ˜¯æˆç«‹çš„.</p>
<p>æœ€å, <code>config.hasFlow(_, sink)</code> ä¸­å°†sourceéƒ¨åˆ†è®¾ç½®ä¸º<code>_</code>, å› ä¸ºæˆ‘ä»¬çš„æŸ¥è¯¢ä¸­å¹¶ä¸åŒ…å«source, è€Œ<code>comparison.getOperand() = sink</code>ä¹Ÿæ˜¯æ–¹ä¾¿å»æŸ¥è¯¢å‡ºç›¸åº”çš„æ¯”è¾ƒæµ‹è¯•èŠ‚ç‚¹.</p>
<h3 id="22-find-the-true-bug">2.2: Find the true bug!<a hidden class="anchor" aria-hidden="true" href="#22-find-the-true-bug">#</a></h3>
<blockquote>
<p>We can now put this dataflow query together with our query from step 1.6, and find all if statements that</p>
</blockquote>
<blockquote>
<ul>
<li>Are one of the equality tests returned in 2.1</li>
<li>Are testing equality against ErrNone</li>
<li>Do not contain a return statement in their then branch</li>
</ul>
</blockquote>
<pre tabindex="0"><code class="language-ql" data-lang="ql">import go

class AuthTestConfig extends DataFlow::Configuration {

  AuthTestConfig() { this = &#34;auth-test-config&#34; }

  override predicate isSource(DataFlow::Node source) {
    source = any(DataFlow::CallNode cn |
      cn.getTarget().hasQualifiedName(&#34;github.com/minio/minio/cmd&#34;, &#34;isReqAuthenticated&#34;)
    ).getResult()
  }

  override predicate isSink(DataFlow::Node sink) {
    sink = any(DataFlow::EqualityTestNode n).getAnOperand()
  }

}

EqualityTestExpr getAnAuthCheck() {
  exists(AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison |
    config.hasFlow(_, sink) and comparison.getAnOperand() = sink |
    result = comparison.asExpr()
  )
}

from IfStmt i
where
i.getCond() = getAnAuthCheck() and
i.getCond().(EqualityTestExpr).getAnOperand().(Ident).getName() = &#34;ErrNone&#34;
and not i.getThen().getAStmt() instanceof ReturnStmt
select i
</code></pre><p>å°†ä¹‹å‰çš„éƒ¨åˆ†ç»“åˆèµ·æ¥å°±å¯ä»¥äº†. è¿™é‡Œæ–°å‡ºç°äº†ä¸€ä¸ª<code>exists</code>, å…¶ç”¨æ³•ä¸º:</p>
<pre tabindex="0"><code>exists(&lt;variable declarations&gt; | &lt;formula&gt;)
</code></pre><p>å½“å­˜åœ¨ä¸€ä¸ªå˜é‡ä½¿å¾—formulaæˆç«‹, å…¬å¼æˆç«‹, è€Œformulaå¯ä»¥æœ‰å¤šä¸ª, å³</p>
<pre tabindex="0"><code>exists(&lt;variable declarations&gt; | &lt;formula 1&gt; | &lt;formula 2&gt; |...| &lt;formula n&gt;)
</code></pre><p>ç­‰ä»·äº</p>
<pre tabindex="0"><code>exists(&lt;variable declarations&gt; | &lt;formula 1&gt; and &lt;formula 2&gt; and...and &lt;formula n&gt;)
</code></pre><p>å¦‚æœè‡³å°‘å­˜åœ¨ä¸€ç»„variablesä½¿å¾—å…¨éƒ¨formulaéƒ½æ»¡è¶³, é‚£ä¹ˆå…¬å¼æˆç«‹.</p>
<p>è€Œé¢˜è§£ä¸­çš„è¿™ç§å†™æ³•, ç›¸å½“äºç­‰å‰é¢æ‰€æœ‰çš„formulaéƒ½æ»¡è¶³çš„æ—¶å€™, ä¸´æ—¶å˜é‡resultä¼šè¢«èµ‹å€¼ <code>comparison.asExpr()</code> , è€Œresultåˆæ˜¯ <code>getAnAuthCheck</code> çš„è¿”å›å€¼, å› æ­¤å°±å˜æˆ: è¿”å›ä¸€ç»„æ»¡è¶³è¿ç®—å•å…ƒæ˜¯æ±¡ç‚¹æºçš„ <code>EqualityTestExpr</code>.</p>
<h2 id="part-3-expanding-the-query">Part 3: Expanding the query<a hidden class="anchor" aria-hidden="true" href="#part-3-expanding-the-query">#</a></h2>
<p>è¿™éƒ¨åˆ†è¦æ‰©å¤§èŒƒå›´, ä¸å†å±€é™äºMinIOäº†, ä½¿ç”¨çš„æ£€æµ‹å¯¹è±¡æ˜¯è¿™é“é¢˜ç›®é™„å¸¦çš„database.</p>
<h3 id="31-conditional-polarity">3.1: Conditional polarity<a hidden class="anchor" aria-hidden="true" href="#31-conditional-polarity">#</a></h3>
<blockquote>
<p>You might have noticed this in step 1.6: our code looking for equality tests encompases both x == ErrNone and x != ErrNone and checks the then block in both cases. This is wrong. It ought to check the &ldquo;then&rdquo; or &ldquo;else&rdquo; case of an if block, depending on which form of conditional is used. Modify your query to fix this problem. Your query should be able to detect all bad examples in conditionalPolarities.go.
Hint: Check out the predicate EqualityTestExpr.getPolarity</p>
</blockquote>
<p>éœ€è¦æ ¹æ®<code>x==ErrNone</code>å’Œ<code>x!=ErrNone</code>çš„ä¸åŒæƒ…å†µè¿›è¡Œä¸åŒæ£€æŸ¥.</p>
<pre tabindex="0"><code class="language-ql" data-lang="ql">import go

class AuthTestConfig extends DataFlow::Configuration {

  AuthTestConfig() { this = &#34;auth-test-config&#34; }

  override predicate isSource(DataFlow::Node source) {
    source = any(DataFlow::CallNode cn |
      cn.getTarget().hasQualifiedName(&#34;github.com/minio/minio/cmd&#34;, &#34;isReqAuthenticated&#34;) or
      // Note new source function:
      cn.getTarget().hasQualifiedName(&#34;github.com/github/codeql-ctf-go-return&#34;, &#34;errorSource&#34;)
    ).getResult()
  }

  override predicate isSink(DataFlow::Node sink) {
    sink = any(DataFlow::EqualityTestNode n).getAnOperand()
  }

}

EqualityTestExpr getADirectAuthCheck(boolean polarity) {
  exists(AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison |
    config.hasFlow(_, sink) and comparison.getAnOperand() = sink |
    result = comparison.asExpr() and
    polarity = result.getPolarity()
  )
}

/**
 * Given `ifStmt`&#39;s condition compares some `x` against `ErrNone` with `polarity` (true means checking
 * equality; false checking inequality), return the block reached when `x != ErrNone`.
 */
BlockStmt getErrorBranch(IfStmt ifStmt, boolean polarity) {
  polarity = [true, false] and
  if polarity = true then result = ifStmt.getElse() else result = ifStmt.getThen()
}

from IfStmt i, boolean testPolarity
where
i.getCond() = getADirectAuthCheck(testPolarity) and
i.getCond().(EqualityTestExpr).getAnOperand().(Ident).getName() = &#34;ErrNone&#34;
and not getErrorBranch(i, testPolarity).getAStmt() instanceof ReturnStmt
select i
</code></pre><p>é‡ç‚¹æ˜¯<code>if polarity = true then result = ifStmt.getElse() else result = ifStmt.getThen()</code>è¿™ä¸€å¥.</p>
<p>å¦å¤–<code>polarity = [true, false]</code>è¿™ä¸ªæ˜¯å¯¹å˜é‡çš„é™åˆ¶, åœ¨<a href="https://codeql.github.com/docs/ql-language-reference/predicates/#binding-behavior">æ–‡æ¡£</a>ä¸­æœ‰ç›¸å…³çš„æè¿°</p>
<blockquote>
<p>It must be possible to evaluate a predicate in a finite amount of time, so the set it describes is not usually allowed to be infinite. In other words, a predicate can only contain a finite number of tuples.</p>
</blockquote>
<p>å¦‚æœæ²¡æœ‰<code>polarity = [true, false]</code>, è™½ç„¶ç†è®ºä¸Šæ¥è¯´booleanå˜é‡ä¹Ÿåªæœ‰ä¸¤ä¸ªå€¼, ä½†æ˜¯ç»Ÿä¸€èµ·è§è¿˜æ˜¯éœ€è¦åšé™åˆ¶.</p>
<h3 id="32-more-blocks">3.2: More blocks<a hidden class="anchor" aria-hidden="true" href="#32-more-blocks">#</a></h3>
<blockquote>
<p>Let&rsquo;s detect more blocks that must return. For example, our query fails to detect a return statement in an else branch, and there are other such cases that we need to handle, such as cascading else or switch/case. Modify your query to find more blocks that donâ€™t return. Your query should be able to detect all bad examples in moreWaysToReturn.go.
Hints:
While we could recursively inspect the control-flow structures inside the if block, it may help to use the control-flow graph. Check the documentation of the class IR::ReturnInstruction, a control-flow graph node corresponding to a return statement, and the getAPredecessor() / getASuccessor() methods of its superclass ControlFlow::Node, which traverse control-flow graph edges.
A passing or failing if test is always followed by a ConditionGuardNode that indicates which branch was taken.</p>
</blockquote>
<blockquote>
<p>Tip: Try creating a temporary query such as the one below to get an idea what the control flow graph looks like.</p>
</blockquote>
<pre tabindex="0"><code class="language-ql" data-lang="ql">from ControlFlow::Node pred, ControlFlow::Node succ 
    where succ = pred.getASuccessor() // you can also restrict `pred` to come from a particular source file
    select pred, succ
</code></pre><p>è¦å¯»æ‰¾æ›´å¤šåˆ†æ”¯è¯­å¥ä¸­çš„æ²¡æœ‰è¿”å›çš„éƒ¨åˆ†.</p>
<pre tabindex="0"><code class="language-ql" data-lang="ql">import go

class AuthTestConfig extends DataFlow::Configuration {

  AuthTestConfig() { this = &#34;auth-test-config&#34; }

  override predicate isSource(DataFlow::Node source) {
    source = any(DataFlow::CallNode cn |
      cn.getTarget().hasQualifiedName(&#34;github.com/minio/minio/cmd&#34;, &#34;isReqAuthenticated&#34;) or
      cn.getTarget().hasQualifiedName(&#34;github.com/github/codeql-ctf-go-return&#34;, &#34;errorSource&#34;)
    ).getResult()
  }

  override predicate isSink(DataFlow::Node sink) {
    sink = any(DataFlow::EqualityTestNode n).getAnOperand()
  }

}

EqualityTestExpr getAnAuthCheck() {
  exists(AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison |
    config.hasFlow(_, sink) and comparison.getAnOperand() = sink |
    result = comparison.asExpr()
  )
}

ReturnStmt getAReturnStatementInBlock(BlockStmt b) {
  result = b.getAChild*()
}

predicate mustReachReturnInBlock(ControlFlow::Node node, BlockStmt b) {
  node.(IR::ReturnInstruction).getReturnStmt() = getAReturnStatementInBlock(b) or
  forex(ControlFlow::Node succ | succ = node.getASuccessor() | mustReachReturnInBlock(succ, b))
}

from IfStmt i, ControlFlow::ConditionGuardNode ifSucc
where
i.getCond() = getAnAuthCheck() and
i.getCond().(EqualityTestExpr).getAnOperand().(Ident).getName() = &#34;ErrNone&#34; and
ifSucc.ensures(DataFlow::exprNode(i.getCond()), true) and
not mustReachReturnInBlock(ifSucc, i.getThen())
select i
</code></pre><p><code>ifSucc.ensures(DataFlow::exprNode(i.getCond()), true)</code> æ¶‰åŠåˆ°äº†æ§åˆ¶æµèŠ‚ç‚¹<code>ifSucc</code>, è¿™æ¡è¯­å¥çš„æ„æ€æ˜¯ <strong>ç¡®ä¿<code>i.getCond()</code>çš„æ¡ä»¶æˆç«‹</strong>, æˆç«‹ä¹‹åæ‰å¯¹thenåˆ†æ”¯çš„è¯­å¥è¿›è¡Œåˆ†æ.</p>
<p>å…³äºConditionGuardNode, <a href="https://codeql.github.com/docs/codeql-language-guides/codeql-library-for-go/#condition-guard-nodes">æ–‡æ¡£</a>ä¸­çš„æœ‰ç›´è§‚çš„å®ä¾‹.</p>
<p>å¯¹äºä»¥ä¸‹ä»£ç </p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">f</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>
</span></span></code></pre></div><p>å…¶ConditionGuardNodeä¸ºå›¾ä¸­çš„<code>p != nil is true</code>å’Œ<code>p != nil is false</code>.</p>
<hr>
<p>å½“å˜é‡è°ƒç”¨è°“è¯(predicate)çš„æ—¶å€™, å¦‚æœå­˜åœ¨ç»“æœ, é‚£ä¹ˆè¿™ç§è°ƒç”¨æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼, å¦åˆ™å°±æ˜¯ä¸€ä¸ªå…¬å¼. è¿”å›ç»“æœçš„è°“è¯å¯ä»¥åœ¨ç»è¿‡é€»è¾‘åˆ¤æ–­åè¿”å›å¤šä¸ªç»“æœ, ä¾‹å¦‚</p>
<pre tabindex="0"><code class="language-ql" data-lang="ql">string getANeighbor(string country) {
  country = &#34;France&#34; and result = &#34;Belgium&#34;
  or
  country = &#34;France&#34; and result = &#34;Germany&#34;
  or
  country = &#34;Germany&#34; and result = &#34;Austria&#34;
  or
  country = &#34;Germany&#34; and result = &#34;Belgium&#34;
}
</code></pre><p>å¯¹äºä¸Šè¿°predicate, å¦‚æœ<code>country</code>ä¸º&quot;Germany&quot;, é‚£ä¹ˆè¿”å›å€¼ä¸ºAustriaå’ŒBelgium, è¿™ç‚¹å’Œå¹³æ—¶ç”¨çš„ç¼–ç¨‹è¯­è¨€åŒºåˆ«æŒºå¤§çš„.</p>
<p>åŒæ ·çš„, <code>b.getAChild()</code>æ˜¯ä¸€ä¸ªå¸¦ç»“æœçš„è°“è¯è°ƒç”¨, ä¼šè¿”å›å¤šä¸ªå­èŠ‚ç‚¹.</p>
<p>æ¥ä¸‹æ¥æ˜¯ä»£è¡¨é—­åŒ…ä¼ é€’çš„<code>*</code>å’Œ<code>+</code>, è¿™ä¸¤ä¸ªéƒ½æœ‰è¿­ä»£çš„åŠŸèƒ½, ä¾‹å¦‚<code>ReturnStmt getAChild*()</code> ç­‰ä»·äº</p>
<pre tabindex="0"><code class="language-ql" data-lang="ql">ReturnStmt getOneChild() {
  result = this
  or
  result = this.getAChild().getOneChild()
}
</code></pre><p>è€Œ<code>ReturnStmt getAChild+()</code> ç­‰ä»·äº</p>
<pre tabindex="0"><code class="language-ql" data-lang="ql">ReturnStmt getOneChild() {
  result = this.getAChild()
  or
  result = this.getAChild().getOneChild()
}
</code></pre><p>ä¹Ÿå°±æ˜¯è¯´<code>*</code>ç›¸æ¯”è¾ƒ<code>+</code>è¿˜åŒ…å«äº†è‡ªèº«.</p>
<p>é‚£ä¹ˆ<code>getAReturnStatementInBlock</code>çš„ç»“æœå°±æ˜¯å½“å‰èŠ‚ç‚¹åŠ ä¸Šå½“å‰èŠ‚ç‚¹ç»è¿‡é€’å½’åçš„æ‰€æœ‰å­èŠ‚ç‚¹.</p>
<p>é‚£ä¹ˆå­èŠ‚ç‚¹çš„é›†åˆè¦æ€ä¹ˆå’Œ<code>node.(IR::ReturnInstruction).getReturnStmt()</code>è¿›è¡Œæ¯”è¾ƒ? æ ¹æ®<a href="https://codeql.github.com/docs/ql-language-reference/formulas/#equality-1">æ–‡æ¡£</a>ä¸­æ‰€æè¿°çš„:</p>
<blockquote>
<p>For expressions A and B, the formula A = B holds if there is a pair of valuesâ€”one from A and one from Bâ€”that are the same. In other words, A and B have at least one value in common. For example, [1 .. 2] = [2 .. 5] holds, since both expressions have the value 2.</p>
</blockquote>
<p>é‚£ä¹ˆå°±ä¸éš¾ç†è§£äº†, åªè¦<code>node.(IR::ReturnInstruction).getReturnStmt()</code>çš„å€¼å’Œå…¶ä¸­ä¸€ä¸ªç›¸åŒ, <code>mustReachReturnInBlock</code>å°±ä¼šæˆç«‹, ä¸ç„¶å°±è¿›å…¥<code>forex</code>éƒ¨åˆ†.</p>
<p><code>forex</code>çš„ç”¨æ³•, æ ¹æ®<a href="https://codeql.github.com/docs/ql-language-reference/formulas/#forex">æ–‡æ¡£</a>, å¯ä»¥çœ‹ä½œæ˜¯<code>forall</code> å’Œ <code>exists</code> çš„ç»“åˆ. ä¸‰è€…çš„å®šä¹‰å¦‚ä¸‹</p>
<pre tabindex="0"><code>forall(&lt;variable declarations&gt; | &lt;formula 1&gt; | &lt;formula 2&gt;)
forex(&lt;variable declarations&gt; | &lt;formula 1&gt; | &lt;formula 2&gt;) ç­‰ä»·äº forall(&lt;vars&gt; | &lt;formula 1&gt; | &lt;formula 2&gt;) and exists(&lt;vars&gt; | &lt;formula 1&gt; | &lt;formula 2&gt;)
</code></pre><ul>
<li><code>forall</code>: å½“æ¯ä¸€ä¸ªè®©formula1 æˆç«‹çš„å˜é‡åœ¨formula2æˆç«‹çš„æ—¶å€™, å…¬å¼æˆç«‹</li>
<li><code>forex</code>: å’Œ<code>forall</code>ç±»ä¼¼, ä½†æ˜¯æ’é™¤äº†<code>ä¸å­˜åœ¨æ»¡è¶³formula1çš„å˜é‡çš„æƒ…å†µ</code>, å› ä¸ºè¿™ç§æƒ…å†µä¸‹<code>formula2</code>ä¼šæ— æ¡ä»¶æˆç«‹.</li>
</ul>
<p>é‚£ä¹ˆä»£ç ä¸­<code>forex</code>çš„æ„æ€å°±æ˜¯: <strong>å¯¹äºnodeçš„successor, è¦æ±‚successorå­˜åœ¨, å¹¶ä¸”æ¯ä¸€ä¸ªsuccessoræ»¡è¶³mustReachReturnInBlock, ä¹Ÿå°±æ˜¯è¯´æ¯ä¸€ä¸ªsuccessoréƒ½å­˜åœ¨ReturnStmt</strong></p>
<hr>
<p>åœ¨æŸ¥é˜…æ–‡æ¡£çš„æ—¶å€™å¯ä»¥æ³¨æ„ç±»çš„<code>supertypes</code>éƒ½æœ‰å“ªäº›, åŒ…æ‹¬<code>Direct supertypes</code> å’Œ <code>Indirect supertypes</code>. æ‰€è°“<code>Indirect supertypes</code>å°±æ˜¯æŒ‡, <code>supertype</code>åœ¨ç»å†äº†å¤šæ¬¡ç»§æ‰¿ä¹‹åæ‰èƒ½å˜æˆè¯¥ç±», è€Œ<code>direct supertypes</code> æ˜¯ç›´æ¥ç»§æ‰¿çš„. è¿™äº›<code>supertypes</code>éƒ½å¯ä»¥é€šè¿‡ç±»å‹è½¬æ¢å˜æˆè¿™ä¸ªç±».</p>
<h3 id="33-wrapped-conditionals">3.3: Wrapped conditionals<a hidden class="anchor" aria-hidden="true" href="#33-wrapped-conditionals">#</a></h3>
<blockquote>
<p>Now we can have cases where our equality test against ErrNone is no longer directly used in a conditional statement, but is instead wrapped inside a utility function. Modify your query to handle this case. Your query should be able to detect all bad examples in wrapperFunctions.go.</p>
</blockquote>
<p>Hint:</p>
<ul>
<li>You can have several layers in your wrap!</li>
<li>Check out the predicates CallExpr::getTarget(), DataFlow::CallNode::getTarget() and Function::getFuncDecl() to navigate between a callsite and its callee.</li>
</ul>
<p>ç›¸æ¯”è¾ƒä¹‹å‰çš„ç›´æ¥æŸ¥è¯¢ifè¯­å¥ä¸­çš„å†…å®¹, è¿™é‡Œè¦æ±‚é¢å¤–è¦†ç›–ä½¿ç”¨å‡½æ•°è¿”å›å€¼è¿›è¡Œåˆ¤æ–­çš„æƒ…å†µ, ä¾‹å¦‚</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">succeeded</span>(<span style="color:#a6e22e">errorSource</span>()) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">doSomething</span>()
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Bad: despite an error, we carry on to execute doSomething()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">insteadOfReturn</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code class="language-ql" data-lang="ql">import go

class AuthTestConfig extends DataFlow::Configuration {

  AuthTestConfig() { this = &#34;auth-test-config&#34; }

  override predicate isSource(DataFlow::Node source) {
    source = any(DataFlow::CallNode cn |
      cn.getTarget().hasQualifiedName(&#34;github.com/minio/minio/cmd&#34;, &#34;isReqAuthenticated&#34;) or
      // Note new source function:
      cn.getTarget().hasQualifiedName(&#34;github.com/github/codeql-ctf-go-return&#34;, &#34;errorSource&#34;)
    ).getResult()
  }

  override predicate isSink(DataFlow::Node sink) {
    sink = any(DataFlow::EqualityTestNode n).getAnOperand()
  }

}

EqualityTestExpr getADirectAuthCheck(boolean polarity) {
  exists(AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison |
    config.hasFlow(_, sink) and comparison.getAnOperand() = sink |
    result = comparison.asExpr() and
    result.getAnOperand().(Ident).getName() = &#34;ErrNone&#34; and
    polarity = result.getPolarity()
  )
}

CallExpr getACheckCall(boolean polarity, FuncDecl target, Expr innerCheck) {
  innerCheck = getAnAuthCheck(polarity) and
  target = result.getTarget().getFuncDecl() and
  forex(DataFlow::ResultNode rn | rn.getRoot() = target | rn.asExpr() = innerCheck)
}

Expr getAnAuthCheck(boolean polarity) {
  result = getADirectAuthCheck(polarity) or
  result = getACheckCall(polarity, _, _)
}

/**
 * Given `ifStmt`&#39;s condition compares some `x` against `ErrNone` with `polarity` (true means checking
 * equality; false checking inequality), return the block reached when `x != ErrNone`.
 */
BlockStmt getErrorBranch(IfStmt ifStmt, boolean polarity) {
  polarity = [true, false] and
  if polarity = true then result = ifStmt.getElse() else result = ifStmt.getThen()
}

from IfStmt i, boolean testPolarity
where
i.getCond() = getAnAuthCheck(testPolarity)
and not getErrorBranch(i, testPolarity).getAStmt() instanceof ReturnStmt
select i
</code></pre><p><code>getErrorBranch</code> æ²¡ä»€ä¹ˆå¥½è¯´çš„, å°±æ˜¯æ ¹æ®<code>polarity</code>é€‰æ‹©elseåˆ†æ”¯æˆ–è€…thenåˆ†æ”¯.</p>
<p>ä½†æ˜¯<code>getAnAuthCheck</code>å°±ä¸åŒäº†, è¿™é‡Œç”¨åˆ°äº†ä¸€ä¸ªç›¸å½“é«˜çº§çš„å†™æ³•: ç›¸äº’é€’å½’(Mutal Recursion), è¿™ä¼šå½¢æˆè°“è¯ä¹‹é—´çš„ä¾èµ–é“¾æ¡, å¯ä»¥çœ‹<a href="https://codeql.github.com/docs/ql-language-reference/recursion/#mutual-recursion">æ–‡æ¡£</a> ç»™å‡ºçš„ä¸€ä¸ªä¾‹å­.</p>
<pre tabindex="0"><code class="language-ql" data-lang="ql">int getAnEven() {
  result = 0
  or
  result &lt;= 100 and result = getAnOdd() + 1
}

int getAnOdd() {
  result = getAnEven() + 1
}

select getAnEven()
</code></pre><p>åœ¨è¿™ä¸ªä¾‹å­ä¸­<code>getAnEven</code>å’Œ<code>getAnOdd</code>ä¹‹é—´å½¢æˆäº†è°“è¯ä¾èµ–é“¾æ¡, codeqlä¼šæŒç»­é€’å½’åˆ°é™åˆ¶æ¡ä»¶åè¿”å›0åˆ°100çš„å¶æ•°.</p>
<p><code>getAnAuthCheck</code>å’Œ<code>getACheckCall</code>ä¹‹é—´ä¹Ÿå­˜åœ¨ç›¸äº’é€’å½’çš„å…³ç³». <code>getAnAuthCheck</code> é¦–å…ˆæ ¹æ®<code>polarity</code>çš„å€¼å»é€‰æ‹©<code>xxx==ErrNone</code>æˆ–<code>xxx!=ErrorNone</code>è¿™ä¸¤ç§sinkå¹¶è½¬åŒ–ä¸ºè¡¨è¾¾å¼, å’Œä¹‹å‰çš„å·®ä¸å¤š, è€Œ<code>getACheckCall</code>ä¸­, é¦–å…ˆä¼šåè¿‡æ¥é€’å½’è·å–<code>getAnAuthCheck</code>çš„ç»“æœ.</p>
<p>å®šä¹‰<code>target</code>ä¸ºå‡½æ•°çš„å£°æ˜, åŒæ—¶ä¹Ÿå¯¹<code>CallExpr</code>ç±»å‹çš„<code>result</code>ä½œäº†éšå¼çš„å®šä¹‰.</p>
<p>æ¥ä¸‹æ¥, <code>forex</code>å¯¹æ¯ä¸€ä¸ª<code>DataFlow::ResultNode</code> è¿›è¡Œæ£€æŸ¥, <code>DataFlow::ResultNode</code> åœ¨<a href="https://codeql.github.com/codeql-standard-libraries/go/semmle/go/dataflow/internal/DataFlowNodes.qll/type.DataFlowNodes$Public$ResultNode.html">æ–‡æ¡£</a>ä¸­æè¿°ä¸º:</p>
<blockquote>
<p>This can either be a node corresponding to an expression in a return statement, or a node representing the current value of a named result variable at the exit of the function.</p>
</blockquote>
<p>è€Œ<code>getRoot</code>èƒ½å¤Ÿè·å–èŠ‚ç‚¹æ‰€å±çš„å‡½æ•°, è¿™ä¸ª<code>forex</code>çš„æ„æ€å°±æˆä¸ºäº† <strong>è¦æ±‚æ¯ä¸€ä¸ªResultNodeæ‰€å±çš„å‡½æ•°éƒ½ä¸targetä»£è¡¨çš„å‡½æ•°å¯¹åº”, åŒæ—¶ResultNodeçš„è¡¨è¾¾å¼æ˜¯getAnAuthCheckçš„ç»“æœ, ä¹Ÿå°±æ˜¯innerCheck</strong></p>
<p>é‚£ä¹ˆ<code>innerCheck</code>ä¹Ÿå°±æ˜¯<code>getAnAuthCheck(polarity)</code>, ä»£è¡¨çš„å°±æ˜¯<strong>æ¡ä»¶åˆ¤æ–­çš„sink, ä»¥åŠæ¡ä»¶åˆ¤æ–­ä¸­æ‰€ä½¿ç”¨çš„å­˜åœ¨æ¡ä»¶åˆ¤æ–­sinkçš„å‡½æ•°</strong>.</p>
<h3 id="34-more-conditionals">3.4: More conditionals<a hidden class="anchor" aria-hidden="true" href="#34-more-conditionals">#</a></h3>
<blockquote>
<p>Our code works for simple equality tests, but there are cases where this test is part of a bigger test with conditionals involving !, &amp;&amp;, ||, that are not currently accounted for in our query. Improve your query to handle these cases. Your query should be able to detect all bad examples in logicalOperators.go.
Hint: Check out ControlFlow::ConditionGuardNode. This node flags a point in a control-flow graph where a particular test is known to have passed or failed, including those nested within the short-circuiting binary logical operators &amp;&amp;, ||. Its predicate ensures can already analyse some boolean expression structure. Even if you cannot use it directly, the implementation of ensures may be a useful inspiration for your solution. See the hints for Step 3.2 for more information about the control-flow graph.</p>
</blockquote>
<p>ä¹Ÿå°±æ˜¯è¯´è¦å¯¹!x, x||y, x &amp;&amp; y, (x) è¿™äº›æƒ…å†µè¿›è¡Œå¤„ç†.</p>
<pre tabindex="0"><code class="language-ql" data-lang="ql">import go

class AuthTestConfig extends DataFlow::Configuration {

  AuthTestConfig() { this = &#34;auth-test-config&#34; }

  override predicate isSource(DataFlow::Node source) {
    source = any(DataFlow::CallNode cn |
      cn.getTarget().hasQualifiedName(&#34;github.com/minio/minio/cmd&#34;, &#34;isReqAuthenticated&#34;) or
      // Note new source function:
      cn.getTarget().hasQualifiedName(&#34;github.com/github/codeql-ctf-go-return&#34;, &#34;errorSource&#34;)
    ).getResult()
  }

  override predicate isSink(DataFlow::Node sink) {
    sink = any(DataFlow::EqualityTestNode n).getAnOperand()
  }

}

EqualityTestExpr getADirectAuthCheck(boolean polarity) {
  exists(AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison |
    config.hasFlow(_, sink) and comparison.getAnOperand() = sink |
    result = comparison.asExpr() and
    polarity = result.getPolarity()
  )
}

Expr getAnAuthCheck(Boolean noError, EqualityTestExpr test) {
  result = getADirectAuthCheck(noError) and test = result
  or
  result.(ParenExpr).getExpr() = getAnAuthCheck(noError, test)
  or
  result.(NotExpr).getOperand() = getAnAuthCheck(noError.booleanNot(), test)
  or
  result.(LandExpr).getRightOperand() = getAnAuthCheck(noError, test)
  or
  result.(LandExpr).getLeftOperand() = getAnAuthCheck(true, test) and noError = true
  or
  result.(LandExpr).getLeftOperand() = getAnAuthCheck(false, test) and noError = [true, false]
  or
  result.(LorExpr).getRightOperand() = getAnAuthCheck(noError, test)
  or
  result.(LorExpr).getLeftOperand() = getAnAuthCheck(false, test) and noError = false
  or
  result.(LorExpr).getLeftOperand() = getAnAuthCheck(true, test) and noError = [true, false]
}


BlockStmt getErrorBranch(IfStmt ifStmt, boolean polarity) {
  polarity = [true, false] and
  if polarity = true then result = ifStmt.getElse() else result = ifStmt.getThen()
}

from IfStmt i, EqualityTestExpr test
where
test.getAnOperand().(Ident).getName() = &#34;ErrNone&#34;
and not forall(boolean testPolarity |
  i.getCond() = getAnAuthCheck(testPolarity, test) |
  exists(Stmt s | s = getErrorBranch(i, testPolarity).getAStmt() | s instanceof ReturnStmt))
and i.getFile().getBaseName() = &#34;logicalOperators.go&#34;
select i
</code></pre><p><code>getAnAuthCheck</code>æ˜¯é‡ç‚¹</p>
<pre tabindex="0"><code class="language-ql" data-lang="ql">// ä½¿ç”¨testæ¥çº¦æŸç›´æ¥æ£€æŸ¥çš„ç»“æœ: å¿…é¡»æ˜¯æœ‰ErrNoneå‚ä¸çš„ç­‰å¼æ£€æŸ¥
  result = getADirectAuthCheck(noError) and result = test
or
  // å¯¹getAnAuthCheckçš„ç»“æœè¿›è¡Œçº¦æŸ, ç»“æœå¿…é¡»ä¸ºä¸€ä¸ªParenExprä¸­å»æ‰æ‹¬å·çš„Expr
    // å¦‚æœå­˜åœ¨è¿™æ ·çš„ç»“æœ, é‚£ä¹ˆè¿™é‡Œçš„resultå°±æ»¡è¶³è¦æ±‚äº†
  result.(ParenExpr).getExpr() = getAnAuthCheck(noError, test)
or
  // å¯¹getAnAuthCheckçš„ç»“æœè¿›è¡Œçº¦æŸ, ç»“æœå¿…é¡»ä¸ºä¸€ä¸ªNotExprä¸­å»æ‰Notéƒ¨åˆ†çš„Expr
  result.(NotExpr).getOperand() = getAnAuthCheck(noError.booleanNot(), test)
</code></pre><p>ä½†æ˜¯æ¥ä¸‹æ¥çš„é‚£å‡ ä¸ªANDå’ŒORç›¸å…³çš„å¤„ç†æˆ‘å°±çœ‹ä¸æ‡‚äº†, åç»­å†è¯´å§.</p>
<p>æœ€ååº”è¯¥è¯´æ˜ä¸€ä¸‹<code>forall</code>å’Œ<code>exists</code>çš„ç»„åˆä½¿ç”¨:</p>
<pre tabindex="0"><code class="language-ql" data-lang="ql">// æ‰€æœ‰æ»¡è¶³æ±¡ç‚¹å’ŒErrNoneå‚ä¸çš„æ¡ä»¶æ£€æŸ¥ä¸­, æ¯ä¸€ä¸ªåˆ†æ”¯é‡Œéƒ½å­˜åœ¨è¿”å›è¯­å¥
forall(boolean testPolarity |
  i.getCond() = getAnAuthCheck(testPolarity, test) |
// å¦‚æœé”™è¯¯åˆ†æ”¯ä¸­å­˜åœ¨è¿”å›è¯­å¥, é‚£ä¹ˆæˆç«‹
  exists(Stmt s | s = getErrorBranch(i, testPolarity).getAStmt() | s instanceof ReturnStmt))
</code></pre><p>å°†ä¸Šé¢çš„é€»è¾‘å–å, å°±å˜æˆäº† <strong>æ‰€æœ‰æ»¡è¶³æ±¡ç‚¹å’ŒErrNoneå‚ä¸çš„æ¡ä»¶æ£€æŸ¥ä¸­, å­˜åœ¨ä¸åŒ…å«è¿”å›è¯­å¥çš„åˆ†æ”¯</strong>.</p>
<h3 id="35-valid-returns-only">3.5: Valid returns only<a hidden class="anchor" aria-hidden="true" href="#35-valid-returns-only">#</a></h3>
<blockquote>
<p>Ok, so now we make sure we return something when we check the permission. But is that enough? Just returning somehow isn&rsquo;t good enough, we may also need to return an appropriate value. The use of non-nil / nil error values is normal to indicate an error in Go, so letâ€™s assume for this problem that non-nil is considered an appropriate return value. Modify your query to detect all bad examples in checkReturnValue.go.</p>
</blockquote>
<p>éœ€è¦æ£€æµ‹é‚£äº›å’ŒErrNoneæ¯”è¾ƒåå¯èƒ½è¿”å›nilçš„æƒ…å†µ.</p>
<pre tabindex="0"><code class="language-ql" data-lang="ql">
import go

class AuthTestConfig extends DataFlow::Configuration {

  AuthTestConfig() { this = &#34;auth-test-config&#34; }

  override predicate isSource(DataFlow::Node source) {
    source = any(DataFlow::CallNode cn |
      cn.getTarget().hasQualifiedName(&#34;github.com/minio/minio/cmd&#34;, &#34;isReqAuthenticated&#34;) or
      // Note new source function:
      cn.getTarget().hasQualifiedName(&#34;github.com/github/codeql-ctf-go-return&#34;, &#34;errorSource&#34;)
    ).getResult()
  }

  override predicate isSink(DataFlow::Node sink) {
    sink = any(DataFlow::EqualityTestNode n).getAnOperand()
  }

}

predicate returnsNil(FuncDecl f) {
  forex(DataFlow::ResultNode r | r.getRoot() = f | r = Builtin::nil().getARead())
}

predicate isNil(Expr e) {
  e = any(CallExpr c | returnsNil(c.getTarget().getFuncDecl())) or
  e = Builtin::nil().getAReference()
}

EqualityTestExpr getADirectAuthCheck(boolean polarity) {
  exists(AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison |
    config.hasFlow(_, sink) and comparison.getAnOperand() = sink |
    result = comparison.asExpr() and
    polarity = result.getPolarity()
  )
}

/**
 * Given `ifStmt`&#39;s condition compares some `x` against `ErrNone` with `polarity` (true means checking
 * equality; false checking inequality), return the block reached when `x != ErrNone`.
 */
BlockStmt getErrorBranch(IfStmt ifStmt, boolean polarity) {
  polarity = [true, false] and
  if polarity = true then result = ifStmt.getElse() else result = ifStmt.getThen()
}

from IfStmt i, boolean testPolarity, int resultIdx
where
i.getCond() = getADirectAuthCheck(testPolarity) and
i.getCond().(EqualityTestExpr).getAnOperand().(Ident).getName() = &#34;ErrNone&#34; and
i.getEnclosingFunction().getType().getResultType(resultIdx) = Builtin::error().getType() and // i æ‰€å±å‡½æ•°çš„è¿”å›å€¼ç±»å‹ä¸­æœ‰é”™è¯¯ç±»å‹
not exists(ReturnStmt r |
  r = getErrorBranch(i, testPolarity).getAStmt() |
  not isNil(r.getExpr(resultIdx))
) // è¿™ä¸ªé”™è¯¯ç±»å‹ä¸æ˜¯nil
select i
</code></pre>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://dragonbox.top/posts/tech-domain/">
    <span class="title">Â« Prev</span>
    <br>
    <span>åŸŸåé…åˆéš§é“ç©¿é€æœåŠ¡(Godaddy&#43;Cloudflare&#43;Cpolar)</span>
  </a>
  <a class="next" href="https://dragonbox.top/posts/gossip-scihub/">
    <span class="title">Next Â»</span>
    <br>
    <span>ä»$scihubåˆ°è‡ªç”±ç½‘ç»œæ„å¿—</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://dragonbox.top/">ch3n9w ã® è¶…å…ƒåŸŸ</a></span> Â· 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
